{"ast":null,"code":"import * as THREE from \"three\";\nimport { add, rotateAroundPoint } from \"../utils/three\";\nexport default (function (_ref) {\n  var parent = _ref.parent,\n      world = _ref.world,\n      _ref$items = _ref.items,\n      items = _ref$items === void 0 ? [] : _ref$items,\n      _ref$x = _ref.x,\n      x = _ref$x === void 0 ? 0 : _ref$x,\n      _ref$y = _ref.y,\n      y = _ref$y === void 0 ? 0 : _ref$y,\n      _ref$z = _ref.z,\n      z = _ref$z === void 0 ? 0 : _ref$z,\n      _ref$radius = _ref.radius,\n      radius = _ref$radius === void 0 ? 4 : _ref$radius,\n      _ref$height = _ref.height,\n      height = _ref$height === void 0 ? 0.2 : _ref$height,\n      _ref$color = _ref.color,\n      color = _ref$color === void 0 ? 0xdddddd : _ref$color,\n      _ref$segments = _ref.segments,\n      segments = _ref$segments === void 0 ? 32 : _ref$segments,\n      _ref$opacity = _ref.opacity,\n      opacity = _ref$opacity === void 0 ? 1 : _ref$opacity;\n  var geometry = new THREE.CylinderGeometry(radius, radius + radius * 0.1, height, segments);\n  var material = new THREE.MeshStandardMaterial({\n    color: color,\n    transparent: opacity < 1,\n    opacity: opacity,\n    flatShading: true\n  });\n  var cylinder = new THREE.Mesh(geometry, material);\n  cylinder.position.x = x;\n  cylinder.position.y = y;\n  cylinder.position.z = z;\n  items.forEach(function (item, idx) {\n    item.model.position.z = radius - 1;\n    rotateAroundPoint(item.model, cylinder.position, {\n      y: Math.PI * 2 / items.length * idx\n    });\n    add(cylinder, item);\n    if (item.bodies) item.bodies[0].position.set(item.model.position.x, item.model.position.y, item.model.position.z);\n  });\n  add(parent, cylinder);\n  var primary = world.add({\n    type: \"cylinder\",\n    size: [radius, height],\n    pos: [x, y, z],\n    rot: [0, 0, 0],\n    move: true,\n    density: 0.9,\n    friction: 0.9,\n    restitution: 0.2,\n    belongsTo: 1,\n    collidesWith: 0xffffffff\n  });\n  var base = world.add({\n    type: \"cylinder\",\n    size: [radius, height],\n    pos: [x, y, z],\n    move: false\n  });\n  var hinge = world.add({\n    type: \"jointHinge\",\n    body1: primary,\n    body2: base,\n    axe1: [0, 1, 0],\n    axe2: [0, 1, 0],\n    pos1: [primary.position.x, primary.position.y, primary.position.z],\n    pos2: [base.position.x, base.position.y, base.position.z]\n  });\n  return {\n    model: cylinder,\n    bodies: [primary, base, hinge],\n    timelines: {\n      swipe: {\n        while: true,\n        update: function update(self, entities, timeline, _ref2) {\n          var gamepadController = _ref2.gamepadController;\n          if (gamepadController.rightTrigger) self.bodies[0].angularVelocity.set(0, gamepadController.rightTrigger, 0);else if (gamepadController.leftTrigger) self.bodies[0].angularVelocity.set(0, -gamepadController.leftTrigger, 0);\n        }\n      }\n    }\n  };\n});","map":{"version":3,"sources":["/home/darlington-chuks/Documents/game-engine/src/game/components/turntable.js"],"names":["THREE","add","rotateAroundPoint","parent","world","items","x","y","z","radius","height","color","segments","opacity","geometry","CylinderGeometry","material","MeshStandardMaterial","transparent","flatShading","cylinder","Mesh","position","forEach","item","idx","model","Math","PI","length","bodies","set","primary","type","size","pos","rot","move","density","friction","restitution","belongsTo","collidesWith","base","hinge","body1","body2","axe1","axe2","pos1","pos2","timelines","swipe","while","update","self","entities","timeline","gamepadController","rightTrigger","angularVelocity","leftTrigger"],"mappings":"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","sourcesContent":["import * as THREE from \"three\";\nimport { add, rotateAroundPoint } from \"../utils/three\";\n\nexport default ({ parent, world, items = [], x = 0, y = 0, z = 0, radius = 4, height = 0.2, color = 0xdddddd, segments = 32, opacity = 1 }) => {\n\n\tconst geometry = new THREE.CylinderGeometry(radius, radius + radius * 0.1, height, segments);\n\tconst material = new THREE.MeshStandardMaterial({ color, transparent: opacity < 1, opacity, flatShading: true });\n\tconst cylinder = new THREE.Mesh(geometry, material);\n\n\tcylinder.position.x = x;\n\tcylinder.position.y = y;\n\tcylinder.position.z = z;\n\n\titems.forEach((item, idx) => {\n\t\titem.model.position.z = radius - 1;\n\t\trotateAroundPoint(item.model, cylinder.position, { y: ((Math.PI * 2) / items.length) * idx })\n\t\tadd(cylinder, item);\n\n\t\tif (item.bodies) \n\t\t\titem.bodies[0].position.set(item.model.position.x, item.model.position.y, item.model.position.z)\n\t})\n\t\n\tadd(parent, cylinder);\n\n\tconst primary = world.add({ \n\t    type: \"cylinder\",\n\t    size: [radius, height],\n\t    pos: [x, y, z],\n\t    rot: [0, 0, 0],\n\t    move: true,\n\t    density: 0.9,\n\t    friction: 0.9,\n\t    restitution: 0.2,\n\t    belongsTo: 1,\n\t    collidesWith: 0xffffffff\n\t});\n\n\tconst base = world.add({ type: \"cylinder\", size: [radius, height], pos: [x, y, z], move: false });\n\n\tconst hinge = world.add({\n\t\ttype: \"jointHinge\",\n\t\tbody1: primary, \n\t\tbody2: base,\n\t\taxe1: [0, 1, 0],\n\t\taxe2: [0, 1, 0],\n\t\tpos1: [primary.position.x, primary.position.y, primary.position.z],\n\t\tpos2: [base.position.x, base.position.y, base.position.z]\n\t});\n\n\treturn {\n\t\tmodel: cylinder,\n\t\tbodies: [primary, base, hinge],\n\t\ttimelines: {\n\t\t\tswipe: {\n\t\t\t\twhile: true,\n\t\t\t\tupdate(self, entities, timeline, { gamepadController }) {\n\t\t\t\t\tif (gamepadController.rightTrigger)\n\t\t\t\t\t\tself.bodies[0].angularVelocity.set(0, gamepadController.rightTrigger, 0)\n\t\t\t\t\telse if (gamepadController.leftTrigger)\n\t\t\t\t\t\tself.bodies[0].angularVelocity.set(0, -gamepadController.leftTrigger, 0)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};"]},"metadata":{},"sourceType":"module"}