{"ast":null,"code":"import * as THREE from \"three\";\n/**\n * @author sunag / http://www.sunag.com.br\n */\n\nvar SkeletonUtils = {\n  retarget: function () {\n    var pos = new THREE.Vector3(),\n        quat = new THREE.Quaternion(),\n        scale = new THREE.Vector3(),\n        bindBoneMatrix = new THREE.Matrix4(),\n        relativeMatrix = new THREE.Matrix4(),\n        globalMatrix = new THREE.Matrix4();\n    return function (target, source, options) {\n      options = options || {};\n      options.preserveMatrix = options.preserveMatrix !== undefined ? options.preserveMatrix : true;\n      options.preservePosition = options.preservePosition !== undefined ? options.preservePosition : true;\n      options.preserveHipPosition = options.preserveHipPosition !== undefined ? options.preserveHipPosition : false;\n      options.useTargetMatrix = options.useTargetMatrix !== undefined ? options.useTargetMatrix : false;\n      options.hip = options.hip !== undefined ? options.hip : \"hip\";\n      options.names = options.names || {};\n      var sourceBones = source.isObject3D ? source.skeleton.bones : this.getBones(source),\n          bones = target.isObject3D ? target.skeleton.bones : this.getBones(target),\n          bindBones,\n          bone,\n          name,\n          boneTo,\n          bonesPosition,\n          i; // reset bones\n\n      if (target.isObject3D) {\n        target.skeleton.pose();\n      } else {\n        options.useTargetMatrix = true;\n        options.preserveMatrix = false;\n      }\n\n      if (options.preservePosition) {\n        bonesPosition = [];\n\n        for (i = 0; i < bones.length; i++) {\n          bonesPosition.push(bones[i].position.clone());\n        }\n      }\n\n      if (options.preserveMatrix) {\n        // reset matrix\n        target.updateMatrixWorld();\n        target.matrixWorld.identity(); // reset children matrix\n\n        for (i = 0; i < target.children.length; ++i) {\n          target.children[i].updateMatrixWorld(true);\n        }\n      }\n\n      if (options.offsets) {\n        bindBones = [];\n\n        for (i = 0; i < bones.length; ++i) {\n          bone = bones[i];\n          name = options.names[bone.name] || bone.name;\n\n          if (options.offsets && options.offsets[name]) {\n            bone.matrix.multiply(options.offsets[name]);\n            bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);\n            bone.updateMatrixWorld();\n          }\n\n          bindBones.push(bone.matrixWorld.clone());\n        }\n      }\n\n      for (i = 0; i < bones.length; ++i) {\n        bone = bones[i];\n        name = options.names[bone.name] || bone.name;\n        boneTo = this.getBoneByName(name, sourceBones);\n        globalMatrix.copy(bone.matrixWorld);\n\n        if (boneTo) {\n          boneTo.updateMatrixWorld();\n\n          if (options.useTargetMatrix) {\n            relativeMatrix.copy(boneTo.matrixWorld);\n          } else {\n            relativeMatrix.getInverse(target.matrixWorld);\n            relativeMatrix.multiply(boneTo.matrixWorld);\n          } // ignore scale to extract rotation\n\n\n          scale.setFromMatrixScale(relativeMatrix);\n          relativeMatrix.scale(scale.set(1 / scale.x, 1 / scale.y, 1 / scale.z)); // apply to global matrix\n\n          globalMatrix.makeRotationFromQuaternion(quat.setFromRotationMatrix(relativeMatrix));\n\n          if (target.isObject3D) {\n            var boneIndex = bones.indexOf(bone),\n                wBindMatrix = bindBones ? bindBones[boneIndex] : bindBoneMatrix.getInverse(target.skeleton.boneInverses[boneIndex]);\n            globalMatrix.multiply(wBindMatrix);\n          }\n\n          globalMatrix.copyPosition(relativeMatrix);\n        }\n\n        if (bone.parent && bone.parent.isBone) {\n          bone.matrix.getInverse(bone.parent.matrixWorld);\n          bone.matrix.multiply(globalMatrix);\n        } else {\n          bone.matrix.copy(globalMatrix);\n        }\n\n        if (options.preserveHipPosition && name === options.hip) {\n          bone.matrix.setPosition(pos.set(0, bone.position.y, 0));\n        }\n\n        bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);\n        bone.updateMatrixWorld();\n      }\n\n      if (options.preservePosition) {\n        for (i = 0; i < bones.length; ++i) {\n          bone = bones[i];\n          name = options.names[bone.name] || bone.name;\n\n          if (name !== options.hip) {\n            bone.position.copy(bonesPosition[i]);\n          }\n        }\n      }\n\n      if (options.preserveMatrix) {\n        // restore matrix\n        target.updateMatrixWorld(true);\n      }\n    };\n  }(),\n  retargetClip: function retargetClip(target, source, clip, options) {\n    options = options || {};\n    options.useFirstFramePosition = options.useFirstFramePosition !== undefined ? options.useFirstFramePosition : false;\n    options.fps = options.fps !== undefined ? options.fps : 30;\n    options.names = options.names || [];\n\n    if (!source.isObject3D) {\n      source = this.getHelperFromSkeleton(source);\n    }\n\n    var numFrames = Math.round(clip.duration * (options.fps / 1000) * 1000),\n        delta = 1 / options.fps,\n        convertedTracks = [],\n        mixer = new THREE.AnimationMixer(source),\n        bones = this.getBones(target.skeleton),\n        boneDatas = [],\n        positionOffset,\n        bone,\n        boneTo,\n        boneData,\n        name,\n        i,\n        j;\n    mixer.clipAction(clip).play();\n    mixer.update(0);\n    source.updateMatrixWorld();\n\n    for (i = 0; i < numFrames; ++i) {\n      var time = i * delta;\n      this.retarget(target, source, options);\n\n      for (j = 0; j < bones.length; ++j) {\n        name = options.names[bones[j].name] || bones[j].name;\n        boneTo = this.getBoneByName(name, source.skeleton);\n\n        if (boneTo) {\n          bone = bones[j];\n          boneData = boneDatas[j] = boneDatas[j] || {\n            bone: bone\n          };\n\n          if (options.hip === name) {\n            if (!boneData.pos) {\n              boneData.pos = {\n                times: new Float32Array(numFrames),\n                values: new Float32Array(numFrames * 3)\n              };\n            }\n\n            if (options.useFirstFramePosition) {\n              if (i === 0) {\n                positionOffset = bone.position.clone();\n              }\n\n              bone.position.sub(positionOffset);\n            }\n\n            boneData.pos.times[i] = time;\n            bone.position.toArray(boneData.pos.values, i * 3);\n          }\n\n          if (!boneData.quat) {\n            boneData.quat = {\n              times: new Float32Array(numFrames),\n              values: new Float32Array(numFrames * 4)\n            };\n          }\n\n          boneData.quat.times[i] = time;\n          bone.quaternion.toArray(boneData.quat.values, i * 4);\n        }\n      }\n\n      mixer.update(delta);\n      source.updateMatrixWorld();\n    }\n\n    for (i = 0; i < boneDatas.length; ++i) {\n      boneData = boneDatas[i];\n\n      if (boneData) {\n        if (boneData.pos) {\n          convertedTracks.push(new THREE.VectorKeyframeTrack(\".bones[\" + boneData.bone.name + \"].position\", boneData.pos.times, boneData.pos.values));\n        }\n\n        convertedTracks.push(new THREE.QuaternionKeyframeTrack(\".bones[\" + boneData.bone.name + \"].quaternion\", boneData.quat.times, boneData.quat.values));\n      }\n    }\n\n    mixer.uncacheAction(clip);\n    return new THREE.AnimationClip(clip.name, -1, convertedTracks);\n  },\n  getHelperFromSkeleton: function getHelperFromSkeleton(skeleton) {\n    var source = new THREE.SkeletonHelper(skeleton.bones[0]);\n    source.skeleton = skeleton;\n    return source;\n  },\n  getSkeletonOffsets: function () {\n    var targetParentPos = new THREE.Vector3(),\n        targetPos = new THREE.Vector3(),\n        sourceParentPos = new THREE.Vector3(),\n        sourcePos = new THREE.Vector3(),\n        targetDir = new THREE.Vector2(),\n        sourceDir = new THREE.Vector2();\n    return function (target, source, options) {\n      options = options || {};\n      options.hip = options.hip !== undefined ? options.hip : \"hip\";\n      options.names = options.names || {};\n\n      if (!source.isObject3D) {\n        source = this.getHelperFromSkeleton(source);\n      }\n\n      var nameKeys = Object.keys(options.names),\n          nameValues = Object.values(options.names),\n          sourceBones = source.isObject3D ? source.skeleton.bones : this.getBones(source),\n          bones = target.isObject3D ? target.skeleton.bones : this.getBones(target),\n          offsets = [],\n          bone,\n          boneTo,\n          name,\n          i;\n      target.skeleton.pose();\n\n      for (i = 0; i < bones.length; ++i) {\n        bone = bones[i];\n        name = options.names[bone.name] || bone.name;\n        boneTo = this.getBoneByName(name, sourceBones);\n\n        if (boneTo && name !== options.hip) {\n          var boneParent = this.getNearestBone(bone.parent, nameKeys),\n              boneToParent = this.getNearestBone(boneTo.parent, nameValues);\n          boneParent.updateMatrixWorld();\n          boneToParent.updateMatrixWorld();\n          targetParentPos.setFromMatrixPosition(boneParent.matrixWorld);\n          targetPos.setFromMatrixPosition(bone.matrixWorld);\n          sourceParentPos.setFromMatrixPosition(boneToParent.matrixWorld);\n          sourcePos.setFromMatrixPosition(boneTo.matrixWorld);\n          targetDir.subVectors(new THREE.Vector2(targetPos.x, targetPos.y), new THREE.Vector2(targetParentPos.x, targetParentPos.y)).normalize();\n          sourceDir.subVectors(new THREE.Vector2(sourcePos.x, sourcePos.y), new THREE.Vector2(sourceParentPos.x, sourceParentPos.y)).normalize();\n          var laterialAngle = targetDir.angle() - sourceDir.angle();\n          var offset = new THREE.Matrix4().makeRotationFromEuler(new THREE.Euler(0, 0, laterialAngle));\n          bone.matrix.multiply(offset);\n          bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);\n          bone.updateMatrixWorld();\n          offsets[name] = offset;\n        }\n      }\n\n      return offsets;\n    };\n  }(),\n  renameBones: function renameBones(skeleton, names) {\n    var bones = this.getBones(skeleton);\n\n    for (var i = 0; i < bones.length; ++i) {\n      var bone = bones[i];\n\n      if (names[bone.name]) {\n        bone.name = names[bone.name];\n      }\n    }\n\n    return this;\n  },\n  getBones: function getBones(skeleton) {\n    return Array.isArray(skeleton) ? skeleton : skeleton.bones;\n  },\n  getBoneByName: function getBoneByName(name, skeleton) {\n    for (var i = 0, bones = this.getBones(skeleton); i < bones.length; i++) {\n      if (name === bones[i].name) return bones[i];\n    }\n  },\n  getNearestBone: function getNearestBone(bone, names) {\n    while (bone.isBone) {\n      if (names.indexOf(bone.name) !== -1) {\n        return bone;\n      }\n\n      bone = bone.parent;\n    }\n  },\n  findBoneTrackData: function findBoneTrackData(name, tracks) {\n    var regexp = /\\[(.*)\\]\\.(.*)/,\n        result = {\n      name: name\n    };\n\n    for (var i = 0; i < tracks.length; ++i) {\n      // 1 is track name\n      // 2 is track type\n      var trackData = regexp.exec(tracks[i].name);\n\n      if (trackData && name === trackData[1]) {\n        result[trackData[2]] = i;\n      }\n    }\n\n    return result;\n  },\n  getEqualsBonesNames: function getEqualsBonesNames(skeleton, targetSkeleton) {\n    var sourceBones = this.getBones(skeleton),\n        targetBones = this.getBones(targetSkeleton),\n        bones = [];\n\n    search: for (var i = 0; i < sourceBones.length; i++) {\n      var boneName = sourceBones[i].name;\n\n      for (var j = 0; j < targetBones.length; j++) {\n        if (boneName === targetBones[j].name) {\n          bones.push(boneName);\n          continue search;\n        }\n      }\n    }\n\n    return bones;\n  },\n  clone: function clone(source) {\n    var sourceLookup = new Map();\n    var cloneLookup = new Map();\n    var clone = source.clone();\n    parallelTraverse(source, clone, function (sourceNode, clonedNode) {\n      sourceLookup.set(clonedNode, sourceNode);\n      cloneLookup.set(sourceNode, clonedNode);\n    });\n    clone.traverse(function (node) {\n      if (!node.isSkinnedMesh) return;\n      var clonedMesh = node;\n      var sourceMesh = sourceLookup.get(node);\n      var sourceBones = sourceMesh.skeleton.bones;\n      clonedMesh.skeleton = sourceMesh.skeleton.clone();\n      clonedMesh.bindMatrix.copy(sourceMesh.bindMatrix);\n      clonedMesh.skeleton.bones = sourceBones.map(function (bone) {\n        return cloneLookup.get(bone);\n      });\n      clonedMesh.bind(clonedMesh.skeleton, clonedMesh.bindMatrix);\n    });\n    return clone;\n  }\n};\n\nfunction parallelTraverse(a, b, callback) {\n  callback(a, b);\n\n  for (var i = 0; i < a.children.length; i++) {\n    parallelTraverse(a.children[i], b.children[i], callback);\n  }\n}\n\nexport default SkeletonUtils;","map":{"version":3,"sources":["/home/darlington-chuks/Documents/game-engine/src/game/utils/three/skeleton-utils.js"],"names":["THREE","SkeletonUtils","retarget","pos","Vector3","quat","Quaternion","scale","bindBoneMatrix","Matrix4","relativeMatrix","globalMatrix","target","source","options","preserveMatrix","undefined","preservePosition","preserveHipPosition","useTargetMatrix","hip","names","sourceBones","isObject3D","skeleton","bones","getBones","bindBones","bone","name","boneTo","bonesPosition","i","pose","length","push","position","clone","updateMatrixWorld","matrixWorld","identity","children","offsets","matrix","multiply","decompose","quaternion","getBoneByName","copy","getInverse","setFromMatrixScale","set","x","y","z","makeRotationFromQuaternion","setFromRotationMatrix","boneIndex","indexOf","wBindMatrix","boneInverses","copyPosition","parent","isBone","setPosition","retargetClip","clip","useFirstFramePosition","fps","getHelperFromSkeleton","numFrames","Math","round","duration","delta","convertedTracks","mixer","AnimationMixer","boneDatas","positionOffset","boneData","j","clipAction","play","update","time","times","Float32Array","values","sub","toArray","VectorKeyframeTrack","QuaternionKeyframeTrack","uncacheAction","AnimationClip","SkeletonHelper","getSkeletonOffsets","targetParentPos","targetPos","sourceParentPos","sourcePos","targetDir","Vector2","sourceDir","nameKeys","Object","keys","nameValues","boneParent","getNearestBone","boneToParent","setFromMatrixPosition","subVectors","normalize","laterialAngle","angle","offset","makeRotationFromEuler","Euler","renameBones","Array","isArray","findBoneTrackData","tracks","regexp","result","trackData","exec","getEqualsBonesNames","targetSkeleton","targetBones","search","boneName","sourceLookup","Map","cloneLookup","parallelTraverse","sourceNode","clonedNode","traverse","node","isSkinnedMesh","clonedMesh","sourceMesh","get","bindMatrix","map","bind","a","b","callback"],"mappings":"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","sourcesContent":["import * as THREE from \"three\";\n\n/**\n * @author sunag / http://www.sunag.com.br\n */\n\nconst SkeletonUtils = {\n\n\tretarget: function () {\n\n\t\tvar pos = new THREE.Vector3(),\n\t\t\tquat = new THREE.Quaternion(),\n\t\t\tscale = new THREE.Vector3(),\n\t\t\tbindBoneMatrix = new THREE.Matrix4(),\n\t\t\trelativeMatrix = new THREE.Matrix4(),\n\t\t\tglobalMatrix = new THREE.Matrix4();\n\n\t\treturn function ( target, source, options ) {\n\n\t\t\toptions = options || {};\n\t\t\toptions.preserveMatrix = options.preserveMatrix !== undefined ? options.preserveMatrix : true;\n\t\t\toptions.preservePosition = options.preservePosition !== undefined ? options.preservePosition : true;\n\t\t\toptions.preserveHipPosition = options.preserveHipPosition !== undefined ? options.preserveHipPosition : false;\n\t\t\toptions.useTargetMatrix = options.useTargetMatrix !== undefined ? options.useTargetMatrix : false;\n\t\t\toptions.hip = options.hip !== undefined ? options.hip : \"hip\";\n\t\t\toptions.names = options.names || {};\n\n\t\t\tvar sourceBones = source.isObject3D ? source.skeleton.bones : this.getBones( source ),\n\t\t\t\tbones = target.isObject3D ? target.skeleton.bones : this.getBones( target ),\n\t\t\t\tbindBones,\n\t\t\t\tbone, name, boneTo,\n\t\t\t\tbonesPosition, i;\n\n\t\t\t// reset bones\n\n\t\t\tif ( target.isObject3D ) {\n\n\t\t\t\ttarget.skeleton.pose();\n\n\t\t\t} else {\n\n\t\t\t\toptions.useTargetMatrix = true;\n\t\t\t\toptions.preserveMatrix = false;\n\n\t\t\t}\n\n\t\t\tif ( options.preservePosition ) {\n\n\t\t\t\tbonesPosition = [];\n\n\t\t\t\tfor ( i = 0; i < bones.length; i ++ ) {\n\n\t\t\t\t\tbonesPosition.push( bones[ i ].position.clone() );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( options.preserveMatrix ) {\n\n\t\t\t\t// reset matrix\n\n\t\t\t\ttarget.updateMatrixWorld();\n\n\t\t\t\ttarget.matrixWorld.identity();\n\n\t\t\t\t// reset children matrix\n\n\t\t\t\tfor ( i = 0; i < target.children.length; ++ i ) {\n\n\t\t\t\t\ttarget.children[ i ].updateMatrixWorld( true );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( options.offsets ) {\n\n\t\t\t\tbindBones = [];\n\n\t\t\t\tfor ( i = 0; i < bones.length; ++ i ) {\n\n\t\t\t\t\tbone = bones[ i ];\n\t\t\t\t\tname = options.names[ bone.name ] || bone.name;\n\n\t\t\t\t\tif ( options.offsets && options.offsets[ name ] ) {\n\n\t\t\t\t\t\tbone.matrix.multiply( options.offsets[ name ] );\n\n\t\t\t\t\t\tbone.matrix.decompose( bone.position, bone.quaternion, bone.scale );\n\n\t\t\t\t\t\tbone.updateMatrixWorld();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbindBones.push( bone.matrixWorld.clone() );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfor ( i = 0; i < bones.length; ++ i ) {\n\n\t\t\t\tbone = bones[ i ];\n\t\t\t\tname = options.names[ bone.name ] || bone.name;\n\n\t\t\t\tboneTo = this.getBoneByName( name, sourceBones );\n\n\t\t\t\tglobalMatrix.copy( bone.matrixWorld );\n\n\t\t\t\tif ( boneTo ) {\n\n\t\t\t\t\tboneTo.updateMatrixWorld();\n\n\t\t\t\t\tif ( options.useTargetMatrix ) {\n\n\t\t\t\t\t\trelativeMatrix.copy( boneTo.matrixWorld );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\trelativeMatrix.getInverse( target.matrixWorld );\n\t\t\t\t\t\trelativeMatrix.multiply( boneTo.matrixWorld );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// ignore scale to extract rotation\n\n\t\t\t\t\tscale.setFromMatrixScale( relativeMatrix );\n\t\t\t\t\trelativeMatrix.scale( scale.set( 1 / scale.x, 1 / scale.y, 1 / scale.z ) );\n\n\t\t\t\t\t// apply to global matrix\n\n\t\t\t\t\tglobalMatrix.makeRotationFromQuaternion( quat.setFromRotationMatrix( relativeMatrix ) );\n\n\t\t\t\t\tif ( target.isObject3D ) {\n\n\t\t\t\t\t\tvar boneIndex = bones.indexOf( bone ),\n\t\t\t\t\t\t\twBindMatrix = bindBones ? bindBones[ boneIndex ] : bindBoneMatrix.getInverse( target.skeleton.boneInverses[ boneIndex ] );\n\n\t\t\t\t\t\tglobalMatrix.multiply( wBindMatrix );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tglobalMatrix.copyPosition( relativeMatrix );\n\n\t\t\t\t}\n\n\t\t\t\tif ( bone.parent && bone.parent.isBone ) {\n\n\t\t\t\t\tbone.matrix.getInverse( bone.parent.matrixWorld );\n\t\t\t\t\tbone.matrix.multiply( globalMatrix );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tbone.matrix.copy( globalMatrix );\n\n\t\t\t\t}\n\n\t\t\t\tif ( options.preserveHipPosition && name === options.hip ) {\n\n\t\t\t\t\tbone.matrix.setPosition( pos.set( 0, bone.position.y, 0 ) );\n\n\t\t\t\t}\n\n\t\t\t\tbone.matrix.decompose( bone.position, bone.quaternion, bone.scale );\n\n\t\t\t\tbone.updateMatrixWorld();\n\n\t\t\t}\n\n\t\t\tif ( options.preservePosition ) {\n\n\t\t\t\tfor ( i = 0; i < bones.length; ++ i ) {\n\n\t\t\t\t\tbone = bones[ i ];\n\t\t\t\t\tname = options.names[ bone.name ] || bone.name;\n\n\t\t\t\t\tif ( name !== options.hip ) {\n\n\t\t\t\t\t\tbone.position.copy( bonesPosition[ i ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( options.preserveMatrix ) {\n\n\t\t\t\t// restore matrix\n\n\t\t\t\ttarget.updateMatrixWorld( true );\n\n\t\t\t}\n\n\t\t};\n\n\t}(),\n\n\tretargetClip: function ( target, source, clip, options ) {\n\n\t\toptions = options || {};\n\t\toptions.useFirstFramePosition = options.useFirstFramePosition !== undefined ? options.useFirstFramePosition : false;\n\t\toptions.fps = options.fps !== undefined ? options.fps : 30;\n\t\toptions.names = options.names || [];\n\n\t\tif ( ! source.isObject3D ) {\n\n\t\t\tsource = this.getHelperFromSkeleton( source );\n\n\t\t}\n\n\t\tvar numFrames = Math.round( clip.duration * ( options.fps / 1000 ) * 1000 ),\n\t\t\tdelta = 1 / options.fps,\n\t\t\tconvertedTracks = [],\n\t\t\tmixer = new THREE.AnimationMixer( source ),\n\t\t\tbones = this.getBones( target.skeleton ),\n\t\t\tboneDatas = [],\n\t\t\tpositionOffset,\n\t\t\tbone, boneTo, boneData,\n\t\t\tname, i, j;\n\n\t\tmixer.clipAction( clip ).play();\n\t\tmixer.update( 0 );\n\n\t\tsource.updateMatrixWorld();\n\n\t\tfor ( i = 0; i < numFrames; ++ i ) {\n\n\t\t\tvar time = i * delta;\n\n\t\t\tthis.retarget( target, source, options );\n\n\t\t\tfor ( j = 0; j < bones.length; ++ j ) {\n\n\t\t\t\tname = options.names[ bones[ j ].name ] || bones[ j ].name;\n\n\t\t\t\tboneTo = this.getBoneByName( name, source.skeleton );\n\n\t\t\t\tif ( boneTo ) {\n\n\t\t\t\t\tbone = bones[ j ];\n\t\t\t\t\tboneData = boneDatas[ j ] = boneDatas[ j ] || { bone: bone };\n\n\t\t\t\t\tif ( options.hip === name ) {\n\n\t\t\t\t\t\tif ( ! boneData.pos ) {\n\n\t\t\t\t\t\t\tboneData.pos = {\n\t\t\t\t\t\t\t\ttimes: new Float32Array( numFrames ),\n\t\t\t\t\t\t\t\tvalues: new Float32Array( numFrames * 3 )\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( options.useFirstFramePosition ) {\n\n\t\t\t\t\t\t\tif ( i === 0 ) {\n\n\t\t\t\t\t\t\t\tpositionOffset = bone.position.clone();\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbone.position.sub( positionOffset );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tboneData.pos.times[ i ] = time;\n\n\t\t\t\t\t\tbone.position.toArray( boneData.pos.values, i * 3 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ! boneData.quat ) {\n\n\t\t\t\t\t\tboneData.quat = {\n\t\t\t\t\t\t\ttimes: new Float32Array( numFrames ),\n\t\t\t\t\t\t\tvalues: new Float32Array( numFrames * 4 )\n\t\t\t\t\t\t};\n\n\t\t\t\t\t}\n\n\t\t\t\t\tboneData.quat.times[ i ] = time;\n\n\t\t\t\t\tbone.quaternion.toArray( boneData.quat.values, i * 4 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tmixer.update( delta );\n\n\t\t\tsource.updateMatrixWorld();\n\n\t\t}\n\n\t\tfor ( i = 0; i < boneDatas.length; ++ i ) {\n\n\t\t\tboneData = boneDatas[ i ];\n\n\t\t\tif ( boneData ) {\n\n\t\t\t\tif ( boneData.pos ) {\n\n\t\t\t\t\tconvertedTracks.push( new THREE.VectorKeyframeTrack(\n\t\t\t\t\t\t\".bones[\" + boneData.bone.name + \"].position\",\n\t\t\t\t\t\tboneData.pos.times,\n\t\t\t\t\t\tboneData.pos.values\n\t\t\t\t\t) );\n\n\t\t\t\t}\n\n\t\t\t\tconvertedTracks.push( new THREE.QuaternionKeyframeTrack(\n\t\t\t\t\t\".bones[\" + boneData.bone.name + \"].quaternion\",\n\t\t\t\t\tboneData.quat.times,\n\t\t\t\t\tboneData.quat.values\n\t\t\t\t) );\n\n\t\t\t}\n\n\t\t}\n\n\t\tmixer.uncacheAction( clip );\n\n\t\treturn new THREE.AnimationClip( clip.name, - 1, convertedTracks );\n\n\t},\n\n\tgetHelperFromSkeleton: function ( skeleton ) {\n\n\t\tvar source = new THREE.SkeletonHelper( skeleton.bones[ 0 ] );\n\t\tsource.skeleton = skeleton;\n\n\t\treturn source;\n\n\t},\n\n\tgetSkeletonOffsets: function () {\n\n\t\tvar targetParentPos = new THREE.Vector3(),\n\t\t\ttargetPos = new THREE.Vector3(),\n\t\t\tsourceParentPos = new THREE.Vector3(),\n\t\t\tsourcePos = new THREE.Vector3(),\n\t\t\ttargetDir = new THREE.Vector2(),\n\t\t\tsourceDir = new THREE.Vector2();\n\n\t\treturn function ( target, source, options ) {\n\n\t\t\toptions = options || {};\n\t\t\toptions.hip = options.hip !== undefined ? options.hip : \"hip\";\n\t\t\toptions.names = options.names || {};\n\n\t\t\tif ( ! source.isObject3D ) {\n\n\t\t\t\tsource = this.getHelperFromSkeleton( source );\n\n\t\t\t}\n\n\t\t\tvar nameKeys = Object.keys( options.names ),\n\t\t\t\tnameValues = Object.values( options.names ),\n\t\t\t\tsourceBones = source.isObject3D ? source.skeleton.bones : this.getBones( source ),\n\t\t\t\tbones = target.isObject3D ? target.skeleton.bones : this.getBones( target ),\n\t\t\t\toffsets = [],\n\t\t\t\tbone, boneTo,\n\t\t\t\tname, i;\n\n\t\t\ttarget.skeleton.pose();\n\n\t\t\tfor ( i = 0; i < bones.length; ++ i ) {\n\n\t\t\t\tbone = bones[ i ];\n\t\t\t\tname = options.names[ bone.name ] || bone.name;\n\n\t\t\t\tboneTo = this.getBoneByName( name, sourceBones );\n\n\t\t\t\tif ( boneTo && name !== options.hip ) {\n\n\t\t\t\t\tvar boneParent = this.getNearestBone( bone.parent, nameKeys ),\n\t\t\t\t\t\tboneToParent = this.getNearestBone( boneTo.parent, nameValues );\n\n\t\t\t\t\tboneParent.updateMatrixWorld();\n\t\t\t\t\tboneToParent.updateMatrixWorld();\n\n\t\t\t\t\ttargetParentPos.setFromMatrixPosition( boneParent.matrixWorld );\n\t\t\t\t\ttargetPos.setFromMatrixPosition( bone.matrixWorld );\n\n\t\t\t\t\tsourceParentPos.setFromMatrixPosition( boneToParent.matrixWorld );\n\t\t\t\t\tsourcePos.setFromMatrixPosition( boneTo.matrixWorld );\n\n\t\t\t\t\ttargetDir.subVectors(\n\t\t\t\t\t\tnew THREE.Vector2( targetPos.x, targetPos.y ),\n\t\t\t\t\t\tnew THREE.Vector2( targetParentPos.x, targetParentPos.y )\n\t\t\t\t\t).normalize();\n\n\t\t\t\t\tsourceDir.subVectors(\n\t\t\t\t\t\tnew THREE.Vector2( sourcePos.x, sourcePos.y ),\n\t\t\t\t\t\tnew THREE.Vector2( sourceParentPos.x, sourceParentPos.y )\n\t\t\t\t\t).normalize();\n\n\t\t\t\t\tvar laterialAngle = targetDir.angle() - sourceDir.angle();\n\n\t\t\t\t\tvar offset = new THREE.Matrix4().makeRotationFromEuler(\n\t\t\t\t\t\tnew THREE.Euler(\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\tlaterialAngle\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\n\t\t\t\t\tbone.matrix.multiply( offset );\n\n\t\t\t\t\tbone.matrix.decompose( bone.position, bone.quaternion, bone.scale );\n\n\t\t\t\t\tbone.updateMatrixWorld();\n\n\t\t\t\t\toffsets[ name ] = offset;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn offsets;\n\n\t\t};\n\n\t}(),\n\n\trenameBones: function ( skeleton, names ) {\n\n\t\tvar bones = this.getBones( skeleton );\n\n\t\tfor ( var i = 0; i < bones.length; ++ i ) {\n\n\t\t\tvar bone = bones[ i ];\n\n\t\t\tif ( names[ bone.name ] ) {\n\n\t\t\t\tbone.name = names[ bone.name ];\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tgetBones: function ( skeleton ) {\n\n\t\treturn Array.isArray( skeleton ) ? skeleton : skeleton.bones;\n\n\t},\n\n\tgetBoneByName: function ( name, skeleton ) {\n\n\t\tfor ( var i = 0, bones = this.getBones( skeleton ); i < bones.length; i ++ ) {\n\n\t\t\tif ( name === bones[ i ].name )\n\n\t\t\t\treturn bones[ i ];\n\n\t\t}\n\n\t},\n\n\tgetNearestBone: function ( bone, names ) {\n\n\t\twhile ( bone.isBone ) {\n\n\t\t\tif ( names.indexOf( bone.name ) !== - 1 ) {\n\n\t\t\t\treturn bone;\n\n\t\t\t}\n\n\t\t\tbone = bone.parent;\n\n\t\t}\n\n\t},\n\n\tfindBoneTrackData: function ( name, tracks ) {\n\n\t\tvar regexp = /\\[(.*)\\]\\.(.*)/,\n\t\t\tresult = { name: name };\n\n\t\tfor ( var i = 0; i < tracks.length; ++ i ) {\n\n\t\t\t// 1 is track name\n\t\t\t// 2 is track type\n\t\t\tvar trackData = regexp.exec( tracks[ i ].name );\n\n\t\t\tif ( trackData && name === trackData[ 1 ] ) {\n\n\t\t\t\tresult[ trackData[ 2 ] ] = i;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn result;\n\n\t},\n\n\tgetEqualsBonesNames: function ( skeleton, targetSkeleton ) {\n\n\t\tvar sourceBones = this.getBones( skeleton ),\n\t\t\ttargetBones = this.getBones( targetSkeleton ),\n\t\t\tbones = [];\n\n\t\tsearch : for ( var i = 0; i < sourceBones.length; i ++ ) {\n\n\t\t\tvar boneName = sourceBones[ i ].name;\n\n\t\t\tfor ( var j = 0; j < targetBones.length; j ++ ) {\n\n\t\t\t\tif ( boneName === targetBones[ j ].name ) {\n\n\t\t\t\t\tbones.push( boneName );\n\n\t\t\t\t\tcontinue search;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn bones;\n\n\t},\n\n\tclone: function ( source ) {\n\n\t\tvar sourceLookup = new Map();\n\t\tvar cloneLookup = new Map();\n\n\t\tvar clone = source.clone();\n\n\t\tparallelTraverse( source, clone, function ( sourceNode, clonedNode ) {\n\n\t\t\tsourceLookup.set( clonedNode, sourceNode );\n\t\t\tcloneLookup.set( sourceNode, clonedNode );\n\n\t\t} );\n\n\t\tclone.traverse( function ( node ) {\n\n\t\t\tif ( ! node.isSkinnedMesh ) return;\n\n\t\t\tvar clonedMesh = node;\n\t\t\tvar sourceMesh = sourceLookup.get( node );\n\t\t\tvar sourceBones = sourceMesh.skeleton.bones;\n\n\t\t\tclonedMesh.skeleton = sourceMesh.skeleton.clone();\n\t\t\tclonedMesh.bindMatrix.copy( sourceMesh.bindMatrix );\n\n\t\t\tclonedMesh.skeleton.bones = sourceBones.map( function ( bone ) {\n\n\t\t\t\treturn cloneLookup.get( bone );\n\n\t\t\t} );\n\n\t\t\tclonedMesh.bind( clonedMesh.skeleton, clonedMesh.bindMatrix );\n\n\t\t} );\n\n\t\treturn clone;\n\n\t}\n\n};\n\n\nfunction parallelTraverse( a, b, callback ) {\n\n\tcallback( a, b );\n\n\tfor ( var i = 0; i < a.children.length; i ++ ) {\n\n\t\tparallelTraverse( a.children[ i ], b.children[ i ], callback );\n\n\t}\n\n}\n\nexport default SkeletonUtils;"]},"metadata":{},"sourceType":"module"}