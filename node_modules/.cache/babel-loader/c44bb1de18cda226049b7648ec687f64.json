{"ast":null,"code":"//////////////////////////////////////////////////////////////\n// http://mrl.nyu.edu/~perlin/noise/\n// Adapting from PApplet.java\n// which was adapted from toxi\n// which was adapted from the german demo group farbrausch\n// as used in their demo \"art\": http://www.farb-rausch.de/fr010src.zip\n// someday we might consider using \"improved noise\"\n// http://mrl.nyu.edu/~perlin/paper445.pdf\n// See: https://github.com/shiffman/The-Nature-of-Code-Examples-p5.js/\n//      blob/master/introduction/Noise1D/noise.js\n\n/**\n * @module Math\n * @submodule Noise\n * @for p5\n * @requires core\n */\nvar PERLIN_YWRAPB = 4;\nvar PERLIN_YWRAP = 1 << PERLIN_YWRAPB;\nvar PERLIN_ZWRAPB = 8;\nvar PERLIN_ZWRAP = 1 << PERLIN_ZWRAPB;\nvar PERLIN_SIZE = 4095;\nvar perlin_octaves = 4; // default to medium smooth\n\nvar perlin_amp_falloff = 0.5; // 50% reduction/octave\n\nvar scaled_cosine = function scaled_cosine(i) {\n  return 0.5 * (1.0 - Math.cos(i * Math.PI));\n};\n\nvar perlin; // will be initialized lazily by noise() or noiseSeed()\n\n/**\n * Returns the Perlin noise value at specified coordinates. Perlin noise is\n * a random sequence generator producing a more natural ordered, harmonic\n * succession of numbers compared to the standard <b>random()</b> function.\n * It was invented by Ken Perlin in the 1980s and been used since in\n * graphical applications to produce procedural textures, natural motion,\n * shapes, terrains etc.<br /><br /> The main difference to the\n * <b>random()</b> function is that Perlin noise is defined in an infinite\n * n-dimensional space where each pair of coordinates corresponds to a\n * fixed semi-random value (fixed only for the lifespan of the program; see\n * the <a href=\"#/p5/noiseSeed\">noiseSeed()</a> function). p5.js can compute 1D, 2D and 3D noise,\n * depending on the number of coordinates given. The resulting value will\n * always be between 0.0 and 1.0. The noise value can be animated by moving\n * through the noise space as demonstrated in the example above. The 2nd\n * and 3rd dimension can also be interpreted as time.<br /><br />The actual\n * noise is structured similar to an audio signal, in respect to the\n * function's use of frequencies. Similar to the concept of harmonics in\n * physics, perlin noise is computed over several octaves which are added\n * together for the final result. <br /><br />Another way to adjust the\n * character of the resulting sequence is the scale of the input\n * coordinates. As the function works within an infinite space the value of\n * the coordinates doesn't matter as such, only the distance between\n * successive coordinates does (eg. when using <b>noise()</b> within a\n * loop). As a general rule the smaller the difference between coordinates,\n * the smoother the resulting noise sequence will be. Steps of 0.005-0.03\n * work best for most applications, but this will differ depending on use.\n *\n *\n * @method noise\n * @param  {Number} x   x-coordinate in noise space\n * @param  {Number} [y] y-coordinate in noise space\n * @param  {Number} [z] z-coordinate in noise space\n * @return {Number}     Perlin noise value (between 0 and 1) at specified\n *                      coordinates\n * @example\n * <div>\n * <code>\n * var xoff = 0.0;\n *\n * function draw() {\n *   background(204);\n *   xoff = xoff + 0.01;\n *   var n = noise(xoff) * width;\n *   line(n, 0, n, height);\n * }\n * </code>\n * </div>\n * <div>\n * <code>var noiseScale=0.02;\n *\n * function draw() {\n *   background(0);\n *   for (var x=0; x < width; x++) {\n *     var noiseVal = noise((mouseX+x)*noiseScale, mouseY*noiseScale);\n *     stroke(noiseVal*255);\n *     line(x, mouseY+noiseVal*80, x, height);\n *   }\n * }\n * </code>\n * </div>\n *\n * @alt\n * vertical line moves left to right with updating noise values.\n * horizontal wave pattern effected by mouse x-position & updating noise values.\n *\n */\n\nvar noise = function noise(x, y, z) {\n  y = y || 0;\n  z = z || 0;\n\n  if (perlin == null) {\n    perlin = new Array(PERLIN_SIZE + 1);\n\n    for (var i = 0; i < PERLIN_SIZE + 1; i++) {\n      perlin[i] = Math.random();\n    }\n  }\n\n  if (x < 0) {\n    x = -x;\n  }\n\n  if (y < 0) {\n    y = -y;\n  }\n\n  if (z < 0) {\n    z = -z;\n  }\n\n  var xi = Math.floor(x),\n      yi = Math.floor(y),\n      zi = Math.floor(z);\n  var xf = x - xi;\n  var yf = y - yi;\n  var zf = z - zi;\n  var rxf, ryf;\n  var r = 0;\n  var ampl = 0.5;\n  var n1, n2, n3;\n\n  for (var o = 0; o < perlin_octaves; o++) {\n    var of = xi + (yi << PERLIN_YWRAPB) + (zi << PERLIN_ZWRAPB);\n    rxf = scaled_cosine(xf);\n    ryf = scaled_cosine(yf);\n    n1 = perlin[of & PERLIN_SIZE];\n    n1 += rxf * (perlin[of + 1 & PERLIN_SIZE] - n1);\n    n2 = perlin[of + PERLIN_YWRAP & PERLIN_SIZE];\n    n2 += rxf * (perlin[of + PERLIN_YWRAP + 1 & PERLIN_SIZE] - n2);\n    n1 += ryf * (n2 - n1);\n    of += PERLIN_ZWRAP;\n    n2 = perlin[of & PERLIN_SIZE];\n    n2 += rxf * (perlin[of + 1 & PERLIN_SIZE] - n2);\n    n3 = perlin[of + PERLIN_YWRAP & PERLIN_SIZE];\n    n3 += rxf * (perlin[of + PERLIN_YWRAP + 1 & PERLIN_SIZE] - n3);\n    n2 += ryf * (n3 - n2);\n    n1 += scaled_cosine(zf) * (n2 - n1);\n    r += n1 * ampl;\n    ampl *= perlin_amp_falloff;\n    xi <<= 1;\n    xf *= 2;\n    yi <<= 1;\n    yf *= 2;\n    zi <<= 1;\n    zf *= 2;\n\n    if (xf >= 1.0) {\n      xi++;\n      xf--;\n    }\n\n    if (yf >= 1.0) {\n      yi++;\n      yf--;\n    }\n\n    if (zf >= 1.0) {\n      zi++;\n      zf--;\n    }\n  }\n\n  return r;\n};\n/**\n *\n * Adjusts the character and level of detail produced by the Perlin noise\n * function. Similar to harmonics in physics, noise is computed over\n * several octaves. Lower octaves contribute more to the output signal and\n * as such define the overall intensity of the noise, whereas higher octaves\n * create finer grained details in the noise sequence.\n * <br><br>\n * By default, noise is computed over 4 octaves with each octave contributing\n * exactly half than its predecessor, starting at 50% strength for the 1st\n * octave. This falloff amount can be changed by adding an additional function\n * parameter. Eg. a falloff factor of 0.75 means each octave will now have\n * 75% impact (25% less) of the previous lower octave. Any value between\n * 0.0 and 1.0 is valid, however note that values greater than 0.5 might\n * result in greater than 1.0 values returned by <b>noise()</b>.\n * <br><br>\n * By changing these parameters, the signal created by the <b>noise()</b>\n * function can be adapted to fit very specific needs and characteristics.\n *\n * @method noiseDetail\n * @param {Number} lod number of octaves to be used by the noise\n * @param {Number} falloff falloff factor for each octave\n * @example\n * <div>\n * <code>\n * var noiseVal;\n * var noiseScale = 0.02;\n *\n * function setup() {\n *   createCanvas(100, 100);\n * }\n *\n * function draw() {\n *   background(0);\n *   for (var y = 0; y < height; y++) {\n *     for (var x = 0; x < width / 2; x++) {\n *       noiseDetail(2, 0.2);\n *       noiseVal = noise((mouseX + x) * noiseScale, (mouseY + y) * noiseScale);\n *       stroke(noiseVal * 255);\n *       point(x, y);\n *       noiseDetail(8, 0.65);\n *       noiseVal = noise(\n *         (mouseX + x + width / 2) * noiseScale,\n *         (mouseY + y) * noiseScale\n *       );\n *       stroke(noiseVal * 255);\n *       point(x + width / 2, y);\n *     }\n *   }\n * }\n * </code>\n * </div>\n *\n * @alt\n * 2 vertical grey smokey patterns affected my mouse x-position and noise.\n *\n */\n\n\nvar noiseDetail = function noiseDetail(lod, falloff) {\n  if (lod > 0) {\n    perlin_octaves = lod;\n  }\n\n  if (falloff > 0) {\n    perlin_amp_falloff = falloff;\n  }\n};\n/**\n * Sets the seed value for <b>noise()</b>. By default, <b>noise()</b>\n * produces different results each time the program is run. Set the\n * <b>value</b> parameter to a constant to return the same pseudo-random\n * numbers each time the software is run.\n *\n * @method noiseSeed\n * @param {Number} seed   the seed value\n * @example\n * <div>\n * <code>var xoff = 0.0;\n *\n * function setup() {\n *   noiseSeed(99);\n *   stroke(0, 10);\n * }\n *\n * function draw() {\n *   xoff = xoff + .01;\n *   var n = noise(xoff) * width;\n *   line(n, 0, n, height);\n * }\n * </code>\n * </div>\n *\n * @alt\n * vertical grey lines drawing in pattern affected by noise.\n *\n */\n\n\nvar noiseSeed = function noiseSeed(seed) {\n  // Linear Congruential Generator\n  // Variant of a Lehman Generator\n  var lcg = function () {\n    // Set to values from http://en.wikipedia.org/wiki/Numerical_Recipes\n    // m is basically chosen to be large (as it is the max period)\n    // and for its relationships to a and c\n    var m = 4294967296; // a - 1 should be divisible by m's prime factors\n\n    var a = 1664525; // c and m should be co-prime\n\n    var c = 1013904223;\n    var seed, z;\n    return {\n      setSeed: function setSeed(val) {\n        // pick a random seed if val is undefined or null\n        // the >>> 0 casts the seed to an unsigned 32-bit integer\n        z = seed = (val == null ? Math.random() * m : val) >>> 0;\n      },\n      getSeed: function getSeed() {\n        return seed;\n      },\n      rand: function rand() {\n        // define the recurrence relationship\n        z = (a * z + c) % m; // return a float in [0, 1)\n        // if z = m then z / m = 0 therefore (z % m) / m < 1 always\n\n        return z / m;\n      }\n    };\n  }();\n\n  lcg.setSeed(seed);\n  perlin = new Array(PERLIN_SIZE + 1);\n\n  for (var i = 0; i < PERLIN_SIZE + 1; i++) {\n    perlin[i] = lcg.rand();\n  }\n};\n\nmodule.exports = {\n  noise: noise,\n  noiseDetail: noiseDetail,\n  noiseSeed: noiseSeed\n};","map":{"version":3,"sources":["/home/darlington-chuks/Documents/game-engine/src/game/utils/perlin.js"],"names":["PERLIN_YWRAPB","PERLIN_YWRAP","PERLIN_ZWRAPB","PERLIN_ZWRAP","PERLIN_SIZE","perlin_octaves","perlin_amp_falloff","scaled_cosine","i","Math","cos","PI","perlin","noise","x","y","z","Array","random","xi","floor","yi","zi","xf","yf","zf","rxf","ryf","r","ampl","n1","n2","n3","o","of","noiseDetail","lod","falloff","noiseSeed","seed","lcg","m","a","c","setSeed","val","getSeed","rand","module","exports"],"mappings":"AAAA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA,IAAIA,aAAa,GAAG,CAApB;AACA,IAAIC,YAAY,GAAG,KAAKD,aAAxB;AACA,IAAIE,aAAa,GAAG,CAApB;AACA,IAAIC,YAAY,GAAG,KAAKD,aAAxB;AACA,IAAIE,WAAW,GAAG,IAAlB;AAEA,IAAIC,cAAc,GAAG,CAArB,C,CAAwB;;AACxB,IAAIC,kBAAkB,GAAG,GAAzB,C,CAA8B;;AAE9B,IAAIC,aAAa,GAAG,SAAhBA,aAAgB,CAASC,CAAT,EAAY;AAC9B,SAAO,OAAO,MAAMC,IAAI,CAACC,GAAL,CAASF,CAAC,GAAGC,IAAI,CAACE,EAAlB,CAAb,CAAP;AACD,CAFD;;AAIA,IAAIC,MAAJ,C,CAAY;;AAEZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAMC,KAAK,GAAG,SAARA,KAAQ,CAASC,CAAT,EAAYC,CAAZ,EAAeC,CAAf,EAAkB;AAC9BD,EAAAA,CAAC,GAAGA,CAAC,IAAI,CAAT;AACAC,EAAAA,CAAC,GAAGA,CAAC,IAAI,CAAT;;AAEA,MAAIJ,MAAM,IAAI,IAAd,EAAoB;AAClBA,IAAAA,MAAM,GAAG,IAAIK,KAAJ,CAAUb,WAAW,GAAG,CAAxB,CAAT;;AACA,SAAK,IAAII,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,WAAW,GAAG,CAAlC,EAAqCI,CAAC,EAAtC,EAA0C;AACxCI,MAAAA,MAAM,CAACJ,CAAD,CAAN,GAAYC,IAAI,CAACS,MAAL,EAAZ;AACD;AACF;;AAED,MAAIJ,CAAC,GAAG,CAAR,EAAW;AACTA,IAAAA,CAAC,GAAG,CAACA,CAAL;AACD;;AACD,MAAIC,CAAC,GAAG,CAAR,EAAW;AACTA,IAAAA,CAAC,GAAG,CAACA,CAAL;AACD;;AACD,MAAIC,CAAC,GAAG,CAAR,EAAW;AACTA,IAAAA,CAAC,GAAG,CAACA,CAAL;AACD;;AAED,MAAIG,EAAE,GAAGV,IAAI,CAACW,KAAL,CAAWN,CAAX,CAAT;AAAA,MACEO,EAAE,GAAGZ,IAAI,CAACW,KAAL,CAAWL,CAAX,CADP;AAAA,MAEEO,EAAE,GAAGb,IAAI,CAACW,KAAL,CAAWJ,CAAX,CAFP;AAGA,MAAIO,EAAE,GAAGT,CAAC,GAAGK,EAAb;AACA,MAAIK,EAAE,GAAGT,CAAC,GAAGM,EAAb;AACA,MAAII,EAAE,GAAGT,CAAC,GAAGM,EAAb;AACA,MAAII,GAAJ,EAASC,GAAT;AAEA,MAAIC,CAAC,GAAG,CAAR;AACA,MAAIC,IAAI,GAAG,GAAX;AAEA,MAAIC,EAAJ,EAAQC,EAAR,EAAYC,EAAZ;;AAEA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG5B,cAApB,EAAoC4B,CAAC,EAArC,EAAyC;AACvC,QAAIC,EAAE,GAAGf,EAAE,IAAIE,EAAE,IAAIrB,aAAV,CAAF,IAA8BsB,EAAE,IAAIpB,aAApC,CAAT;AAEAwB,IAAAA,GAAG,GAAGnB,aAAa,CAACgB,EAAD,CAAnB;AACAI,IAAAA,GAAG,GAAGpB,aAAa,CAACiB,EAAD,CAAnB;AAEAM,IAAAA,EAAE,GAAGlB,MAAM,CAACsB,EAAE,GAAG9B,WAAN,CAAX;AACA0B,IAAAA,EAAE,IAAIJ,GAAG,IAAId,MAAM,CAAEsB,EAAE,GAAG,CAAN,GAAW9B,WAAZ,CAAN,GAAiC0B,EAArC,CAAT;AACAC,IAAAA,EAAE,GAAGnB,MAAM,CAAEsB,EAAE,GAAGjC,YAAN,GAAsBG,WAAvB,CAAX;AACA2B,IAAAA,EAAE,IAAIL,GAAG,IAAId,MAAM,CAAEsB,EAAE,GAAGjC,YAAL,GAAoB,CAArB,GAA0BG,WAA3B,CAAN,GAAgD2B,EAApD,CAAT;AACAD,IAAAA,EAAE,IAAIH,GAAG,IAAII,EAAE,GAAGD,EAAT,CAAT;AAEAI,IAAAA,EAAE,IAAI/B,YAAN;AACA4B,IAAAA,EAAE,GAAGnB,MAAM,CAACsB,EAAE,GAAG9B,WAAN,CAAX;AACA2B,IAAAA,EAAE,IAAIL,GAAG,IAAId,MAAM,CAAEsB,EAAE,GAAG,CAAN,GAAW9B,WAAZ,CAAN,GAAiC2B,EAArC,CAAT;AACAC,IAAAA,EAAE,GAAGpB,MAAM,CAAEsB,EAAE,GAAGjC,YAAN,GAAsBG,WAAvB,CAAX;AACA4B,IAAAA,EAAE,IAAIN,GAAG,IAAId,MAAM,CAAEsB,EAAE,GAAGjC,YAAL,GAAoB,CAArB,GAA0BG,WAA3B,CAAN,GAAgD4B,EAApD,CAAT;AACAD,IAAAA,EAAE,IAAIJ,GAAG,IAAIK,EAAE,GAAGD,EAAT,CAAT;AAEAD,IAAAA,EAAE,IAAIvB,aAAa,CAACkB,EAAD,CAAb,IAAqBM,EAAE,GAAGD,EAA1B,CAAN;AAEAF,IAAAA,CAAC,IAAIE,EAAE,GAAGD,IAAV;AACAA,IAAAA,IAAI,IAAIvB,kBAAR;AACAa,IAAAA,EAAE,KAAK,CAAP;AACAI,IAAAA,EAAE,IAAI,CAAN;AACAF,IAAAA,EAAE,KAAK,CAAP;AACAG,IAAAA,EAAE,IAAI,CAAN;AACAF,IAAAA,EAAE,KAAK,CAAP;AACAG,IAAAA,EAAE,IAAI,CAAN;;AAEA,QAAIF,EAAE,IAAI,GAAV,EAAe;AACbJ,MAAAA,EAAE;AACFI,MAAAA,EAAE;AACH;;AACD,QAAIC,EAAE,IAAI,GAAV,EAAe;AACbH,MAAAA,EAAE;AACFG,MAAAA,EAAE;AACH;;AACD,QAAIC,EAAE,IAAI,GAAV,EAAe;AACbH,MAAAA,EAAE;AACFG,MAAAA,EAAE;AACH;AACF;;AACD,SAAOG,CAAP;AACD,CA9ED;AAgFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,IAAMO,WAAW,GAAG,SAAdA,WAAc,CAASC,GAAT,EAAcC,OAAd,EAAuB;AACzC,MAAID,GAAG,GAAG,CAAV,EAAa;AACX/B,IAAAA,cAAc,GAAG+B,GAAjB;AACD;;AACD,MAAIC,OAAO,GAAG,CAAd,EAAiB;AACf/B,IAAAA,kBAAkB,GAAG+B,OAArB;AACD;AACF,CAPD;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,IAAMC,SAAS,GAAG,SAAZA,SAAY,CAASC,IAAT,EAAe;AAC/B;AACA;AACA,MAAIC,GAAG,GAAI,YAAW;AACpB;AACA;AACA;AACA,QAAIC,CAAC,GAAG,UAAR,CAJoB,CAKpB;;AACA,QAAIC,CAAC,GAAG,OAAR,CANoB,CAOpB;;AACA,QAAIC,CAAC,GAAG,UAAR;AACA,QAAIJ,IAAJ,EAAUvB,CAAV;AACA,WAAO;AACL4B,MAAAA,OAAO,EAAE,iBAASC,GAAT,EAAc;AACrB;AACA;AACA7B,QAAAA,CAAC,GAAGuB,IAAI,GAAG,CAACM,GAAG,IAAI,IAAP,GAAcpC,IAAI,CAACS,MAAL,KAAgBuB,CAA9B,GAAkCI,GAAnC,MAA4C,CAAvD;AACD,OALI;AAMLC,MAAAA,OAAO,EAAE,mBAAW;AAClB,eAAOP,IAAP;AACD,OARI;AASLQ,MAAAA,IAAI,EAAE,gBAAW;AACf;AACA/B,QAAAA,CAAC,GAAG,CAAC0B,CAAC,GAAG1B,CAAJ,GAAQ2B,CAAT,IAAcF,CAAlB,CAFe,CAGf;AACA;;AACA,eAAOzB,CAAC,GAAGyB,CAAX;AACD;AAfI,KAAP;AAiBD,GA3BS,EAAV;;AA6BAD,EAAAA,GAAG,CAACI,OAAJ,CAAYL,IAAZ;AACA3B,EAAAA,MAAM,GAAG,IAAIK,KAAJ,CAAUb,WAAW,GAAG,CAAxB,CAAT;;AACA,OAAK,IAAII,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,WAAW,GAAG,CAAlC,EAAqCI,CAAC,EAAtC,EAA0C;AACxCI,IAAAA,MAAM,CAACJ,CAAD,CAAN,GAAYgC,GAAG,CAACO,IAAJ,EAAZ;AACD;AACF,CArCD;;AAuCAC,MAAM,CAACC,OAAP,GAAiB;AACfpC,EAAAA,KAAK,EAALA,KADe;AAEfsB,EAAAA,WAAW,EAAXA,WAFe;AAGfG,EAAAA,SAAS,EAATA;AAHe,CAAjB","sourcesContent":["//////////////////////////////////////////////////////////////\n\n// http://mrl.nyu.edu/~perlin/noise/\n// Adapting from PApplet.java\n// which was adapted from toxi\n// which was adapted from the german demo group farbrausch\n// as used in their demo \"art\": http://www.farb-rausch.de/fr010src.zip\n\n// someday we might consider using \"improved noise\"\n// http://mrl.nyu.edu/~perlin/paper445.pdf\n// See: https://github.com/shiffman/The-Nature-of-Code-Examples-p5.js/\n//      blob/master/introduction/Noise1D/noise.js\n\n/**\n * @module Math\n * @submodule Noise\n * @for p5\n * @requires core\n */\n\nvar PERLIN_YWRAPB = 4;\nvar PERLIN_YWRAP = 1 << PERLIN_YWRAPB;\nvar PERLIN_ZWRAPB = 8;\nvar PERLIN_ZWRAP = 1 << PERLIN_ZWRAPB;\nvar PERLIN_SIZE = 4095;\n\nvar perlin_octaves = 4; // default to medium smooth\nvar perlin_amp_falloff = 0.5; // 50% reduction/octave\n\nvar scaled_cosine = function(i) {\n  return 0.5 * (1.0 - Math.cos(i * Math.PI));\n};\n\nvar perlin; // will be initialized lazily by noise() or noiseSeed()\n\n/**\n * Returns the Perlin noise value at specified coordinates. Perlin noise is\n * a random sequence generator producing a more natural ordered, harmonic\n * succession of numbers compared to the standard <b>random()</b> function.\n * It was invented by Ken Perlin in the 1980s and been used since in\n * graphical applications to produce procedural textures, natural motion,\n * shapes, terrains etc.<br /><br /> The main difference to the\n * <b>random()</b> function is that Perlin noise is defined in an infinite\n * n-dimensional space where each pair of coordinates corresponds to a\n * fixed semi-random value (fixed only for the lifespan of the program; see\n * the <a href=\"#/p5/noiseSeed\">noiseSeed()</a> function). p5.js can compute 1D, 2D and 3D noise,\n * depending on the number of coordinates given. The resulting value will\n * always be between 0.0 and 1.0. The noise value can be animated by moving\n * through the noise space as demonstrated in the example above. The 2nd\n * and 3rd dimension can also be interpreted as time.<br /><br />The actual\n * noise is structured similar to an audio signal, in respect to the\n * function's use of frequencies. Similar to the concept of harmonics in\n * physics, perlin noise is computed over several octaves which are added\n * together for the final result. <br /><br />Another way to adjust the\n * character of the resulting sequence is the scale of the input\n * coordinates. As the function works within an infinite space the value of\n * the coordinates doesn't matter as such, only the distance between\n * successive coordinates does (eg. when using <b>noise()</b> within a\n * loop). As a general rule the smaller the difference between coordinates,\n * the smoother the resulting noise sequence will be. Steps of 0.005-0.03\n * work best for most applications, but this will differ depending on use.\n *\n *\n * @method noise\n * @param  {Number} x   x-coordinate in noise space\n * @param  {Number} [y] y-coordinate in noise space\n * @param  {Number} [z] z-coordinate in noise space\n * @return {Number}     Perlin noise value (between 0 and 1) at specified\n *                      coordinates\n * @example\n * <div>\n * <code>\n * var xoff = 0.0;\n *\n * function draw() {\n *   background(204);\n *   xoff = xoff + 0.01;\n *   var n = noise(xoff) * width;\n *   line(n, 0, n, height);\n * }\n * </code>\n * </div>\n * <div>\n * <code>var noiseScale=0.02;\n *\n * function draw() {\n *   background(0);\n *   for (var x=0; x < width; x++) {\n *     var noiseVal = noise((mouseX+x)*noiseScale, mouseY*noiseScale);\n *     stroke(noiseVal*255);\n *     line(x, mouseY+noiseVal*80, x, height);\n *   }\n * }\n * </code>\n * </div>\n *\n * @alt\n * vertical line moves left to right with updating noise values.\n * horizontal wave pattern effected by mouse x-position & updating noise values.\n *\n */\n\nconst noise = function(x, y, z) {\n  y = y || 0;\n  z = z || 0;\n\n  if (perlin == null) {\n    perlin = new Array(PERLIN_SIZE + 1);\n    for (var i = 0; i < PERLIN_SIZE + 1; i++) {\n      perlin[i] = Math.random();\n    }\n  }\n\n  if (x < 0) {\n    x = -x;\n  }\n  if (y < 0) {\n    y = -y;\n  }\n  if (z < 0) {\n    z = -z;\n  }\n\n  var xi = Math.floor(x),\n    yi = Math.floor(y),\n    zi = Math.floor(z);\n  var xf = x - xi;\n  var yf = y - yi;\n  var zf = z - zi;\n  var rxf, ryf;\n\n  var r = 0;\n  var ampl = 0.5;\n\n  var n1, n2, n3;\n\n  for (var o = 0; o < perlin_octaves; o++) {\n    var of = xi + (yi << PERLIN_YWRAPB) + (zi << PERLIN_ZWRAPB);\n\n    rxf = scaled_cosine(xf);\n    ryf = scaled_cosine(yf);\n\n    n1 = perlin[of & PERLIN_SIZE];\n    n1 += rxf * (perlin[(of + 1) & PERLIN_SIZE] - n1);\n    n2 = perlin[(of + PERLIN_YWRAP) & PERLIN_SIZE];\n    n2 += rxf * (perlin[(of + PERLIN_YWRAP + 1) & PERLIN_SIZE] - n2);\n    n1 += ryf * (n2 - n1);\n\n    of += PERLIN_ZWRAP;\n    n2 = perlin[of & PERLIN_SIZE];\n    n2 += rxf * (perlin[(of + 1) & PERLIN_SIZE] - n2);\n    n3 = perlin[(of + PERLIN_YWRAP) & PERLIN_SIZE];\n    n3 += rxf * (perlin[(of + PERLIN_YWRAP + 1) & PERLIN_SIZE] - n3);\n    n2 += ryf * (n3 - n2);\n\n    n1 += scaled_cosine(zf) * (n2 - n1);\n\n    r += n1 * ampl;\n    ampl *= perlin_amp_falloff;\n    xi <<= 1;\n    xf *= 2;\n    yi <<= 1;\n    yf *= 2;\n    zi <<= 1;\n    zf *= 2;\n\n    if (xf >= 1.0) {\n      xi++;\n      xf--;\n    }\n    if (yf >= 1.0) {\n      yi++;\n      yf--;\n    }\n    if (zf >= 1.0) {\n      zi++;\n      zf--;\n    }\n  }\n  return r;\n};\n\n/**\n *\n * Adjusts the character and level of detail produced by the Perlin noise\n * function. Similar to harmonics in physics, noise is computed over\n * several octaves. Lower octaves contribute more to the output signal and\n * as such define the overall intensity of the noise, whereas higher octaves\n * create finer grained details in the noise sequence.\n * <br><br>\n * By default, noise is computed over 4 octaves with each octave contributing\n * exactly half than its predecessor, starting at 50% strength for the 1st\n * octave. This falloff amount can be changed by adding an additional function\n * parameter. Eg. a falloff factor of 0.75 means each octave will now have\n * 75% impact (25% less) of the previous lower octave. Any value between\n * 0.0 and 1.0 is valid, however note that values greater than 0.5 might\n * result in greater than 1.0 values returned by <b>noise()</b>.\n * <br><br>\n * By changing these parameters, the signal created by the <b>noise()</b>\n * function can be adapted to fit very specific needs and characteristics.\n *\n * @method noiseDetail\n * @param {Number} lod number of octaves to be used by the noise\n * @param {Number} falloff falloff factor for each octave\n * @example\n * <div>\n * <code>\n * var noiseVal;\n * var noiseScale = 0.02;\n *\n * function setup() {\n *   createCanvas(100, 100);\n * }\n *\n * function draw() {\n *   background(0);\n *   for (var y = 0; y < height; y++) {\n *     for (var x = 0; x < width / 2; x++) {\n *       noiseDetail(2, 0.2);\n *       noiseVal = noise((mouseX + x) * noiseScale, (mouseY + y) * noiseScale);\n *       stroke(noiseVal * 255);\n *       point(x, y);\n *       noiseDetail(8, 0.65);\n *       noiseVal = noise(\n *         (mouseX + x + width / 2) * noiseScale,\n *         (mouseY + y) * noiseScale\n *       );\n *       stroke(noiseVal * 255);\n *       point(x + width / 2, y);\n *     }\n *   }\n * }\n * </code>\n * </div>\n *\n * @alt\n * 2 vertical grey smokey patterns affected my mouse x-position and noise.\n *\n */\nconst noiseDetail = function(lod, falloff) {\n  if (lod > 0) {\n    perlin_octaves = lod;\n  }\n  if (falloff > 0) {\n    perlin_amp_falloff = falloff;\n  }\n};\n\n/**\n * Sets the seed value for <b>noise()</b>. By default, <b>noise()</b>\n * produces different results each time the program is run. Set the\n * <b>value</b> parameter to a constant to return the same pseudo-random\n * numbers each time the software is run.\n *\n * @method noiseSeed\n * @param {Number} seed   the seed value\n * @example\n * <div>\n * <code>var xoff = 0.0;\n *\n * function setup() {\n *   noiseSeed(99);\n *   stroke(0, 10);\n * }\n *\n * function draw() {\n *   xoff = xoff + .01;\n *   var n = noise(xoff) * width;\n *   line(n, 0, n, height);\n * }\n * </code>\n * </div>\n *\n * @alt\n * vertical grey lines drawing in pattern affected by noise.\n *\n */\nconst noiseSeed = function(seed) {\n  // Linear Congruential Generator\n  // Variant of a Lehman Generator\n  var lcg = (function() {\n    // Set to values from http://en.wikipedia.org/wiki/Numerical_Recipes\n    // m is basically chosen to be large (as it is the max period)\n    // and for its relationships to a and c\n    var m = 4294967296;\n    // a - 1 should be divisible by m's prime factors\n    var a = 1664525;\n    // c and m should be co-prime\n    var c = 1013904223;\n    var seed, z;\n    return {\n      setSeed: function(val) {\n        // pick a random seed if val is undefined or null\n        // the >>> 0 casts the seed to an unsigned 32-bit integer\n        z = seed = (val == null ? Math.random() * m : val) >>> 0;\n      },\n      getSeed: function() {\n        return seed;\n      },\n      rand: function() {\n        // define the recurrence relationship\n        z = (a * z + c) % m;\n        // return a float in [0, 1)\n        // if z = m then z / m = 0 therefore (z % m) / m < 1 always\n        return z / m;\n      }\n    };\n  })();\n\n  lcg.setSeed(seed);\n  perlin = new Array(PERLIN_SIZE + 1);\n  for (var i = 0; i < PERLIN_SIZE + 1; i++) {\n    perlin[i] = lcg.rand();\n  }\n};\n\nmodule.exports = {\n  noise,\n  noiseDetail,\n  noiseSeed\n};"]},"metadata":{},"sourceType":"module"}