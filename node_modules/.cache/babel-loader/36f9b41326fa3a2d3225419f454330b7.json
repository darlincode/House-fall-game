{"ast":null,"code":"import * as THREE from 'three';\n/*\n * GPU Particle System\n * @author flimshaw - Charlie Hoey - http://charliehoey.com\n *\n * A simple to use, general purpose GPU system. Particles are spawn-and-forget with\n * several options available, and do not require monitoring or cleanup after spawning.\n * Because the paths of all particles are completely deterministic once spawned, the scale\n * and direction of time is also variable.\n *\n * Currently uses a static wrapping perlin noise texture for turbulence, and a small png texture for\n * particles, but adding support for a particle texture atlas or changing to a different type of turbulence\n * would be a fairly light day's work.\n *\n * Shader and javascript packing code derrived from several Stack Overflow examples.\n * \n * https://github.com/mrdoob/three.js/blob/dev/examples/js/GPUParticleSystem.js\n * \n */\n\nvar GPUParticleSystem = function GPUParticleSystem(options) {\n  THREE.Object3D.apply(this, arguments);\n  options = options || {}; // parse options and use defaults\n\n  this.PARTICLE_COUNT = options.maxParticles || 1000000;\n  this.PARTICLE_CONTAINERS = options.containerCount || 1;\n  this.PARTICLE_NOISE_TEXTURE = options.particleNoiseTex || null;\n  this.PARTICLE_SPRITE_TEXTURE = options.particleSpriteTex || null;\n  this.PARTICLES_PER_CONTAINER = Math.ceil(this.PARTICLE_COUNT / this.PARTICLE_CONTAINERS);\n  this.PARTICLE_CURSOR = 0;\n  this.time = 0;\n  this.particleContainers = [];\n  this.rand = []; // custom vertex and fragement shader\n\n  var GPUParticleShader = {\n    vertexShader: ['uniform float uTime;', 'uniform float uScale;', 'uniform sampler2D tNoise;', 'attribute vec3 positionStart;', 'attribute float startTime;', 'attribute vec3 velocity;', 'attribute float turbulence;', 'attribute vec3 color;', 'attribute float size;', 'attribute float lifeTime;', 'varying vec4 vColor;', 'varying float lifeLeft;', 'void main() {', // unpack things from our attributes'\n    '\tvColor = vec4( color, 1.0 );', // convert our velocity back into a value we can use'\n    '\tvec3 newPosition;', '\tvec3 v;', '\tfloat timeElapsed = uTime - startTime;', '\tlifeLeft = 1.0 - ( timeElapsed / lifeTime );', '\tgl_PointSize = ( uScale * size ) * lifeLeft;', '\tv.x = ( velocity.x - 0.5 ) * 3.0;', '\tv.y = ( velocity.y - 0.5 ) * 3.0;', '\tv.z = ( velocity.z - 0.5 ) * 3.0;', '\tnewPosition = positionStart + ( v * 10.0 ) * timeElapsed;', '\tvec3 noise = texture2D( tNoise, vec2( newPosition.x * 0.015 + ( uTime * 0.05 ), newPosition.y * 0.02 + ( uTime * 0.015 ) ) ).rgb;', '\tvec3 noiseVel = ( noise.rgb - 0.5 ) * 30.0;', '\tnewPosition = mix( newPosition, newPosition + vec3( noiseVel * ( turbulence * 5.0 ) ), ( timeElapsed / lifeTime ) );', '\tif( v.y > 0. && v.y < .05 ) {', '\t\tlifeLeft = 0.0;', '\t}', '\tif( v.x < - 1.45 ) {', '\t\tlifeLeft = 0.0;', '\t}', '\tif( timeElapsed > 0.0 ) {', '\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( newPosition, 1.0 );', '\t} else {', '\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '\t\tlifeLeft = 0.0;', '\t\tgl_PointSize = 0.;', '\t}', '}'].join('\\n'),\n    fragmentShader: ['float scaleLinear( float value, vec2 valueDomain ) {', '\treturn ( value - valueDomain.x ) / ( valueDomain.y - valueDomain.x );', '}', 'float scaleLinear( float value, vec2 valueDomain, vec2 valueRange ) {', '\treturn mix( valueRange.x, valueRange.y, scaleLinear( value, valueDomain ) );', '}', 'varying vec4 vColor;', 'varying float lifeLeft;', 'uniform sampler2D tSprite;', 'void main() {', '\tfloat alpha = 0.;', '\tif( lifeLeft > 0.995 ) {', '\t\talpha = scaleLinear( lifeLeft, vec2( 1.0, 0.995 ), vec2( 0.0, 1.0 ) );', '\t} else {', '\t\talpha = lifeLeft * 0.75;', '\t}', '\tvec4 tex = texture2D( tSprite, gl_PointCoord );', '\tgl_FragColor = vec4( vColor.rgb * tex.a, alpha * tex.a );', '}'].join('\\n')\n  }; // preload a million random numbers\n\n  var i;\n\n  for (i = 1e5; i > 0; i--) {\n    this.rand.push(Math.random() - 0.5);\n  }\n\n  this.random = function () {\n    return ++i >= this.rand.length ? this.rand[i = 1] : this.rand[i];\n  };\n\n  var textureLoader = new THREE.TextureLoader();\n  this.particleNoiseTex = this.PARTICLE_NOISE_TEXTURE || textureLoader.load('textures/perlin-512.png');\n  this.particleNoiseTex.wrapS = this.particleNoiseTex.wrapT = THREE.RepeatWrapping;\n  this.particleSpriteTex = this.PARTICLE_SPRITE_TEXTURE || textureLoader.load('textures/particle2.png');\n  this.particleSpriteTex.wrapS = this.particleSpriteTex.wrapT = THREE.RepeatWrapping;\n  this.particleShaderMat = new THREE.ShaderMaterial({\n    transparent: true,\n    depthWrite: false,\n    uniforms: {\n      'uTime': {\n        value: 0.0\n      },\n      'uScale': {\n        value: 1.0\n      },\n      'tNoise': {\n        value: this.particleNoiseTex\n      },\n      'tSprite': {\n        value: this.particleSpriteTex\n      }\n    },\n    blending: THREE.AdditiveBlending,\n    vertexShader: GPUParticleShader.vertexShader,\n    fragmentShader: GPUParticleShader.fragmentShader\n  }); // define defaults for all values\n\n  this.particleShaderMat.defaultAttributeValues.particlePositionsStartTime = [0, 0, 0, 0];\n  this.particleShaderMat.defaultAttributeValues.particleVelColSizeLife = [0, 0, 0, 0];\n\n  this.init = function () {\n    for (var i = 0; i < this.PARTICLE_CONTAINERS; i++) {\n      var c = new GPUParticleContainer(this.PARTICLES_PER_CONTAINER, this);\n      this.particleContainers.push(c);\n      this.add(c);\n    }\n  };\n\n  this.spawnParticle = function (options) {\n    this.PARTICLE_CURSOR++;\n\n    if (this.PARTICLE_CURSOR >= this.PARTICLE_COUNT) {\n      this.PARTICLE_CURSOR = 1;\n    }\n\n    var currentContainer = this.particleContainers[Math.floor(this.PARTICLE_CURSOR / this.PARTICLES_PER_CONTAINER)];\n    currentContainer.spawnParticle(options);\n  };\n\n  this.update = function (time) {\n    for (var i = 0; i < this.PARTICLE_CONTAINERS; i++) {\n      this.particleContainers[i].update(time);\n    }\n  };\n\n  this.dispose = function () {\n    this.particleShaderMat.dispose();\n    this.particleNoiseTex.dispose();\n    this.particleSpriteTex.dispose();\n\n    for (var i = 0; i < this.PARTICLE_CONTAINERS; i++) {\n      this.particleContainers[i].dispose();\n    }\n  };\n\n  this.init();\n};\n\nGPUParticleSystem.prototype = Object.create(THREE.Object3D.prototype);\nGPUParticleSystem.prototype.constructor = GPUParticleSystem; // Subclass for particle containers, allows for very large arrays to be spread out\n\nvar GPUParticleContainer = function GPUParticleContainer(maxParticles, particleSystem) {\n  THREE.Object3D.apply(this, arguments);\n  this.PARTICLE_COUNT = maxParticles || 100000;\n  this.PARTICLE_CURSOR = 0;\n  this.time = 0;\n  this.offset = 0;\n  this.count = 0;\n  this.DPR = window.devicePixelRatio;\n  this.GPUParticleSystem = particleSystem;\n  this.particleUpdate = false; // geometry\n\n  this.particleShaderGeo = new THREE.BufferGeometry();\n  this.particleShaderGeo.addAttribute('position', new THREE.BufferAttribute(new Float32Array(this.PARTICLE_COUNT * 3), 3).setDynamic(true));\n  this.particleShaderGeo.addAttribute('positionStart', new THREE.BufferAttribute(new Float32Array(this.PARTICLE_COUNT * 3), 3).setDynamic(true));\n  this.particleShaderGeo.addAttribute('startTime', new THREE.BufferAttribute(new Float32Array(this.PARTICLE_COUNT), 1).setDynamic(true));\n  this.particleShaderGeo.addAttribute('velocity', new THREE.BufferAttribute(new Float32Array(this.PARTICLE_COUNT * 3), 3).setDynamic(true));\n  this.particleShaderGeo.addAttribute('turbulence', new THREE.BufferAttribute(new Float32Array(this.PARTICLE_COUNT), 1).setDynamic(true));\n  this.particleShaderGeo.addAttribute('color', new THREE.BufferAttribute(new Float32Array(this.PARTICLE_COUNT * 3), 3).setDynamic(true));\n  this.particleShaderGeo.addAttribute('size', new THREE.BufferAttribute(new Float32Array(this.PARTICLE_COUNT), 1).setDynamic(true));\n  this.particleShaderGeo.addAttribute('lifeTime', new THREE.BufferAttribute(new Float32Array(this.PARTICLE_COUNT), 1).setDynamic(true)); // material\n\n  this.particleShaderMat = this.GPUParticleSystem.particleShaderMat;\n  var position = new THREE.Vector3();\n  var velocity = new THREE.Vector3();\n  var color = new THREE.Color();\n\n  this.spawnParticle = function (options) {\n    var positionStartAttribute = this.particleShaderGeo.getAttribute('positionStart');\n    var startTimeAttribute = this.particleShaderGeo.getAttribute('startTime');\n    var velocityAttribute = this.particleShaderGeo.getAttribute('velocity');\n    var turbulenceAttribute = this.particleShaderGeo.getAttribute('turbulence');\n    var colorAttribute = this.particleShaderGeo.getAttribute('color');\n    var sizeAttribute = this.particleShaderGeo.getAttribute('size');\n    var lifeTimeAttribute = this.particleShaderGeo.getAttribute('lifeTime');\n    options = options || {}; // setup reasonable default values for all arguments\n\n    position = options.position !== undefined ? position.copy(options.position) : position.set(0, 0, 0);\n    velocity = options.velocity !== undefined ? velocity.copy(options.velocity) : velocity.set(0, 0, 0);\n    color = options.color !== undefined ? color.set(options.color) : color.set(0xffffff);\n    var positionRandomness = options.positionRandomness !== undefined ? options.positionRandomness : 0;\n    var velocityRandomness = options.velocityRandomness !== undefined ? options.velocityRandomness : 0;\n    var colorRandomness = options.colorRandomness !== undefined ? options.colorRandomness : 1;\n    var turbulence = options.turbulence !== undefined ? options.turbulence : 1;\n    var lifetime = options.lifetime !== undefined ? options.lifetime : 5;\n    var size = options.size !== undefined ? options.size : 10;\n    var sizeRandomness = options.sizeRandomness !== undefined ? options.sizeRandomness : 0;\n    var smoothPosition = options.smoothPosition !== undefined ? options.smoothPosition : false;\n    if (this.DPR !== undefined) size *= this.DPR;\n    var i = this.PARTICLE_CURSOR; // position\n\n    positionStartAttribute.array[i * 3 + 0] = position.x + particleSystem.random() * positionRandomness;\n    positionStartAttribute.array[i * 3 + 1] = position.y + particleSystem.random() * positionRandomness;\n    positionStartAttribute.array[i * 3 + 2] = position.z + particleSystem.random() * positionRandomness;\n\n    if (smoothPosition === true) {\n      positionStartAttribute.array[i * 3 + 0] += -(velocity.x * particleSystem.random());\n      positionStartAttribute.array[i * 3 + 1] += -(velocity.y * particleSystem.random());\n      positionStartAttribute.array[i * 3 + 2] += -(velocity.z * particleSystem.random());\n    } // velocity\n\n\n    var maxVel = 2;\n    var velX = velocity.x + particleSystem.random() * velocityRandomness;\n    var velY = velocity.y + particleSystem.random() * velocityRandomness;\n    var velZ = velocity.z + particleSystem.random() * velocityRandomness;\n    velX = THREE.Math.clamp((velX - -maxVel) / (maxVel - -maxVel), 0, 1);\n    velY = THREE.Math.clamp((velY - -maxVel) / (maxVel - -maxVel), 0, 1);\n    velZ = THREE.Math.clamp((velZ - -maxVel) / (maxVel - -maxVel), 0, 1);\n    velocityAttribute.array[i * 3 + 0] = velX;\n    velocityAttribute.array[i * 3 + 1] = velY;\n    velocityAttribute.array[i * 3 + 2] = velZ; // color\n\n    color.r = THREE.Math.clamp(color.r + particleSystem.random() * colorRandomness, 0, 1);\n    color.g = THREE.Math.clamp(color.g + particleSystem.random() * colorRandomness, 0, 1);\n    color.b = THREE.Math.clamp(color.b + particleSystem.random() * colorRandomness, 0, 1);\n    colorAttribute.array[i * 3 + 0] = color.r;\n    colorAttribute.array[i * 3 + 1] = color.g;\n    colorAttribute.array[i * 3 + 2] = color.b; // turbulence, size, lifetime and starttime\n\n    turbulenceAttribute.array[i] = turbulence;\n    sizeAttribute.array[i] = size + particleSystem.random() * sizeRandomness;\n    lifeTimeAttribute.array[i] = lifetime;\n    startTimeAttribute.array[i] = this.time + particleSystem.random() * 2e-2; // offset\n\n    if (this.offset === 0) {\n      this.offset = this.PARTICLE_CURSOR;\n    } // counter and cursor\n\n\n    this.count++;\n    this.PARTICLE_CURSOR++;\n\n    if (this.PARTICLE_CURSOR >= this.PARTICLE_COUNT) {\n      this.PARTICLE_CURSOR = 0;\n    }\n\n    this.particleUpdate = true;\n  };\n\n  this.init = function () {\n    this.particleSystem = new THREE.Points(this.particleShaderGeo, this.particleShaderMat);\n    this.particleSystem.frustumCulled = false;\n    this.add(this.particleSystem);\n  };\n\n  this.update = function (time) {\n    this.time = time;\n    this.particleShaderMat.uniforms.uTime.value = time;\n    this.geometryUpdate();\n  };\n\n  this.geometryUpdate = function () {\n    if (this.particleUpdate === true) {\n      this.particleUpdate = false;\n      var positionStartAttribute = this.particleShaderGeo.getAttribute('positionStart');\n      var startTimeAttribute = this.particleShaderGeo.getAttribute('startTime');\n      var velocityAttribute = this.particleShaderGeo.getAttribute('velocity');\n      var turbulenceAttribute = this.particleShaderGeo.getAttribute('turbulence');\n      var colorAttribute = this.particleShaderGeo.getAttribute('color');\n      var sizeAttribute = this.particleShaderGeo.getAttribute('size');\n      var lifeTimeAttribute = this.particleShaderGeo.getAttribute('lifeTime');\n\n      if (this.offset + this.count < this.PARTICLE_COUNT) {\n        positionStartAttribute.updateRange.offset = this.offset * positionStartAttribute.itemSize;\n        startTimeAttribute.updateRange.offset = this.offset * startTimeAttribute.itemSize;\n        velocityAttribute.updateRange.offset = this.offset * velocityAttribute.itemSize;\n        turbulenceAttribute.updateRange.offset = this.offset * turbulenceAttribute.itemSize;\n        colorAttribute.updateRange.offset = this.offset * colorAttribute.itemSize;\n        sizeAttribute.updateRange.offset = this.offset * sizeAttribute.itemSize;\n        lifeTimeAttribute.updateRange.offset = this.offset * lifeTimeAttribute.itemSize;\n        positionStartAttribute.updateRange.count = this.count * positionStartAttribute.itemSize;\n        startTimeAttribute.updateRange.count = this.count * startTimeAttribute.itemSize;\n        velocityAttribute.updateRange.count = this.count * velocityAttribute.itemSize;\n        turbulenceAttribute.updateRange.count = this.count * turbulenceAttribute.itemSize;\n        colorAttribute.updateRange.count = this.count * colorAttribute.itemSize;\n        sizeAttribute.updateRange.count = this.count * sizeAttribute.itemSize;\n        lifeTimeAttribute.updateRange.count = this.count * lifeTimeAttribute.itemSize;\n      } else {\n        positionStartAttribute.updateRange.offset = 0;\n        startTimeAttribute.updateRange.offset = 0;\n        velocityAttribute.updateRange.offset = 0;\n        turbulenceAttribute.updateRange.offset = 0;\n        colorAttribute.updateRange.offset = 0;\n        sizeAttribute.updateRange.offset = 0;\n        lifeTimeAttribute.updateRange.offset = 0; // Use -1 to update the entire buffer, see #11476\n\n        positionStartAttribute.updateRange.count = -1;\n        startTimeAttribute.updateRange.count = -1;\n        velocityAttribute.updateRange.count = -1;\n        turbulenceAttribute.updateRange.count = -1;\n        colorAttribute.updateRange.count = -1;\n        sizeAttribute.updateRange.count = -1;\n        lifeTimeAttribute.updateRange.count = -1;\n      }\n\n      positionStartAttribute.needsUpdate = true;\n      startTimeAttribute.needsUpdate = true;\n      velocityAttribute.needsUpdate = true;\n      turbulenceAttribute.needsUpdate = true;\n      colorAttribute.needsUpdate = true;\n      sizeAttribute.needsUpdate = true;\n      lifeTimeAttribute.needsUpdate = true;\n      this.offset = 0;\n      this.count = 0;\n    }\n  };\n\n  this.dispose = function () {\n    this.particleShaderGeo.dispose();\n  };\n\n  this.init();\n};\n\nGPUParticleContainer.prototype = Object.create(THREE.Object3D.prototype);\nGPUParticleContainer.prototype.constructor = GPUParticleContainer;\nexport default GPUParticleSystem;","map":{"version":3,"sources":["/home/darlington-chuks/Documents/game-engine/src/game/graphics/gpu-particle-system.js"],"names":["THREE","GPUParticleSystem","options","Object3D","apply","arguments","PARTICLE_COUNT","maxParticles","PARTICLE_CONTAINERS","containerCount","PARTICLE_NOISE_TEXTURE","particleNoiseTex","PARTICLE_SPRITE_TEXTURE","particleSpriteTex","PARTICLES_PER_CONTAINER","Math","ceil","PARTICLE_CURSOR","time","particleContainers","rand","GPUParticleShader","vertexShader","join","fragmentShader","i","push","random","length","textureLoader","TextureLoader","load","wrapS","wrapT","RepeatWrapping","particleShaderMat","ShaderMaterial","transparent","depthWrite","uniforms","value","blending","AdditiveBlending","defaultAttributeValues","particlePositionsStartTime","particleVelColSizeLife","init","c","GPUParticleContainer","add","spawnParticle","currentContainer","floor","update","dispose","prototype","Object","create","constructor","particleSystem","offset","count","DPR","window","devicePixelRatio","particleUpdate","particleShaderGeo","BufferGeometry","addAttribute","BufferAttribute","Float32Array","setDynamic","position","Vector3","velocity","color","Color","positionStartAttribute","getAttribute","startTimeAttribute","velocityAttribute","turbulenceAttribute","colorAttribute","sizeAttribute","lifeTimeAttribute","undefined","copy","set","positionRandomness","velocityRandomness","colorRandomness","turbulence","lifetime","size","sizeRandomness","smoothPosition","array","x","y","z","maxVel","velX","velY","velZ","clamp","r","g","b","Points","frustumCulled","uTime","geometryUpdate","updateRange","itemSize","needsUpdate"],"mappings":"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","sourcesContent":["import * as THREE from 'three';\n\n/*\n * GPU Particle System\n * @author flimshaw - Charlie Hoey - http://charliehoey.com\n *\n * A simple to use, general purpose GPU system. Particles are spawn-and-forget with\n * several options available, and do not require monitoring or cleanup after spawning.\n * Because the paths of all particles are completely deterministic once spawned, the scale\n * and direction of time is also variable.\n *\n * Currently uses a static wrapping perlin noise texture for turbulence, and a small png texture for\n * particles, but adding support for a particle texture atlas or changing to a different type of turbulence\n * would be a fairly light day's work.\n *\n * Shader and javascript packing code derrived from several Stack Overflow examples.\n * \n * https://github.com/mrdoob/three.js/blob/dev/examples/js/GPUParticleSystem.js\n * \n */\n\nconst GPUParticleSystem = function ( options ) {\n\n\tTHREE.Object3D.apply( this, arguments );\n\n\toptions = options || {};\n\n\t// parse options and use defaults\n\n\tthis.PARTICLE_COUNT = options.maxParticles || 1000000;\n\tthis.PARTICLE_CONTAINERS = options.containerCount || 1;\n\n\tthis.PARTICLE_NOISE_TEXTURE = options.particleNoiseTex || null;\n\tthis.PARTICLE_SPRITE_TEXTURE = options.particleSpriteTex || null;\n\n\tthis.PARTICLES_PER_CONTAINER = Math.ceil( this.PARTICLE_COUNT / this.PARTICLE_CONTAINERS );\n\tthis.PARTICLE_CURSOR = 0;\n\tthis.time = 0;\n\tthis.particleContainers = [];\n\tthis.rand = [];\n\n\t// custom vertex and fragement shader\n\n\tvar GPUParticleShader = {\n\n\t\tvertexShader: [\n\n\t\t\t'uniform float uTime;',\n\t\t\t'uniform float uScale;',\n\t\t\t'uniform sampler2D tNoise;',\n\n\t\t\t'attribute vec3 positionStart;',\n\t\t\t'attribute float startTime;',\n\t\t\t'attribute vec3 velocity;',\n\t\t\t'attribute float turbulence;',\n\t\t\t'attribute vec3 color;',\n\t\t\t'attribute float size;',\n\t\t\t'attribute float lifeTime;',\n\n\t\t\t'varying vec4 vColor;',\n\t\t\t'varying float lifeLeft;',\n\n\t\t\t'void main() {',\n\n\t\t\t// unpack things from our attributes'\n\n\t\t\t'\tvColor = vec4( color, 1.0 );',\n\n\t\t\t// convert our velocity back into a value we can use'\n\n\t\t\t'\tvec3 newPosition;',\n\t\t\t'\tvec3 v;',\n\n\t\t\t'\tfloat timeElapsed = uTime - startTime;',\n\n\t\t\t'\tlifeLeft = 1.0 - ( timeElapsed / lifeTime );',\n\n\t\t\t'\tgl_PointSize = ( uScale * size ) * lifeLeft;',\n\n\t\t\t'\tv.x = ( velocity.x - 0.5 ) * 3.0;',\n\t\t\t'\tv.y = ( velocity.y - 0.5 ) * 3.0;',\n\t\t\t'\tv.z = ( velocity.z - 0.5 ) * 3.0;',\n\n\t\t\t'\tnewPosition = positionStart + ( v * 10.0 ) * timeElapsed;',\n\n\t\t\t'\tvec3 noise = texture2D( tNoise, vec2( newPosition.x * 0.015 + ( uTime * 0.05 ), newPosition.y * 0.02 + ( uTime * 0.015 ) ) ).rgb;',\n\t\t\t'\tvec3 noiseVel = ( noise.rgb - 0.5 ) * 30.0;',\n\n\t\t\t'\tnewPosition = mix( newPosition, newPosition + vec3( noiseVel * ( turbulence * 5.0 ) ), ( timeElapsed / lifeTime ) );',\n\n\t\t\t'\tif( v.y > 0. && v.y < .05 ) {',\n\n\t\t\t'\t\tlifeLeft = 0.0;',\n\n\t\t\t'\t}',\n\n\t\t\t'\tif( v.x < - 1.45 ) {',\n\n\t\t\t'\t\tlifeLeft = 0.0;',\n\n\t\t\t'\t}',\n\n\t\t\t'\tif( timeElapsed > 0.0 ) {',\n\n\t\t\t'\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( newPosition, 1.0 );',\n\n\t\t\t'\t} else {',\n\n\t\t\t'\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\n\t\t\t'\t\tlifeLeft = 0.0;',\n\t\t\t'\t\tgl_PointSize = 0.;',\n\n\t\t\t'\t}',\n\n\t\t\t'}'\n\n\t\t].join( '\\n' ),\n\n\t\tfragmentShader: [\n\n\t\t\t'float scaleLinear( float value, vec2 valueDomain ) {',\n\n\t\t\t'\treturn ( value - valueDomain.x ) / ( valueDomain.y - valueDomain.x );',\n\n\t\t\t'}',\n\n\t\t\t'float scaleLinear( float value, vec2 valueDomain, vec2 valueRange ) {',\n\n\t\t\t'\treturn mix( valueRange.x, valueRange.y, scaleLinear( value, valueDomain ) );',\n\n\t\t\t'}',\n\n\t\t\t'varying vec4 vColor;',\n\t\t\t'varying float lifeLeft;',\n\n\t\t\t'uniform sampler2D tSprite;',\n\n\t\t\t'void main() {',\n\n\t\t\t'\tfloat alpha = 0.;',\n\n\t\t\t'\tif( lifeLeft > 0.995 ) {',\n\n\t\t\t'\t\talpha = scaleLinear( lifeLeft, vec2( 1.0, 0.995 ), vec2( 0.0, 1.0 ) );',\n\n\t\t\t'\t} else {',\n\n\t\t\t'\t\talpha = lifeLeft * 0.75;',\n\n\t\t\t'\t}',\n\n\t\t\t'\tvec4 tex = texture2D( tSprite, gl_PointCoord );',\n\t\t\t'\tgl_FragColor = vec4( vColor.rgb * tex.a, alpha * tex.a );',\n\n\t\t\t'}'\n\n\t\t].join( '\\n' )\n\n\t};\n\n\t// preload a million random numbers\n\n\tvar i;\n\n\tfor ( i = 1e5; i > 0; i -- ) {\n\n\t\tthis.rand.push( Math.random() - 0.5 );\n\n\t}\n\n\tthis.random = function () {\n\n\t\treturn ++ i >= this.rand.length ? this.rand[ i = 1 ] : this.rand[ i ];\n\n\t};\n\n\tvar textureLoader = new THREE.TextureLoader();\n\n\tthis.particleNoiseTex = this.PARTICLE_NOISE_TEXTURE || textureLoader.load( 'textures/perlin-512.png' );\n\tthis.particleNoiseTex.wrapS = this.particleNoiseTex.wrapT = THREE.RepeatWrapping;\n\n\tthis.particleSpriteTex = this.PARTICLE_SPRITE_TEXTURE || textureLoader.load( 'textures/particle2.png' );\n\tthis.particleSpriteTex.wrapS = this.particleSpriteTex.wrapT = THREE.RepeatWrapping;\n\n\tthis.particleShaderMat = new THREE.ShaderMaterial( {\n\t\ttransparent: true,\n\t\tdepthWrite: false,\n\t\tuniforms: {\n\t\t\t'uTime': {\n\t\t\t\tvalue: 0.0\n\t\t\t},\n\t\t\t'uScale': {\n\t\t\t\tvalue: 1.0\n\t\t\t},\n\t\t\t'tNoise': {\n\t\t\t\tvalue: this.particleNoiseTex\n\t\t\t},\n\t\t\t'tSprite': {\n\t\t\t\tvalue: this.particleSpriteTex\n\t\t\t}\n\t\t},\n\t\tblending: THREE.AdditiveBlending,\n\t\tvertexShader: GPUParticleShader.vertexShader,\n\t\tfragmentShader: GPUParticleShader.fragmentShader\n\t} );\n\n\t// define defaults for all values\n\n\tthis.particleShaderMat.defaultAttributeValues.particlePositionsStartTime = [ 0, 0, 0, 0 ];\n\tthis.particleShaderMat.defaultAttributeValues.particleVelColSizeLife = [ 0, 0, 0, 0 ];\n\n\tthis.init = function () {\n\n\t\tfor ( var i = 0; i < this.PARTICLE_CONTAINERS; i ++ ) {\n\n\t\t\tvar c = new GPUParticleContainer( this.PARTICLES_PER_CONTAINER, this );\n\t\t\tthis.particleContainers.push( c );\n\t\t\tthis.add( c );\n\n\t\t}\n\n\t};\n\n\tthis.spawnParticle = function ( options ) {\n\n\t\tthis.PARTICLE_CURSOR ++;\n\n\t\tif ( this.PARTICLE_CURSOR >= this.PARTICLE_COUNT ) {\n\n\t\t\tthis.PARTICLE_CURSOR = 1;\n\n\t\t}\n\n\t\tvar currentContainer = this.particleContainers[ Math.floor( this.PARTICLE_CURSOR / this.PARTICLES_PER_CONTAINER ) ];\n\n\t\tcurrentContainer.spawnParticle( options );\n\n\t};\n\n\tthis.update = function ( time ) {\n\n\t\tfor ( var i = 0; i < this.PARTICLE_CONTAINERS; i ++ ) {\n\n\t\t\tthis.particleContainers[ i ].update( time );\n\n\t\t}\n\n\t};\n\n\tthis.dispose = function () {\n\n\t\tthis.particleShaderMat.dispose();\n\t\tthis.particleNoiseTex.dispose();\n\t\tthis.particleSpriteTex.dispose();\n\n\t\tfor ( var i = 0; i < this.PARTICLE_CONTAINERS; i ++ ) {\n\n\t\t\tthis.particleContainers[ i ].dispose();\n\n\t\t}\n\n\t};\n\n\tthis.init();\n\n};\n\nGPUParticleSystem.prototype = Object.create( THREE.Object3D.prototype );\nGPUParticleSystem.prototype.constructor = GPUParticleSystem;\n\n\n// Subclass for particle containers, allows for very large arrays to be spread out\n\nconst GPUParticleContainer = function ( maxParticles, particleSystem ) {\n\n\tTHREE.Object3D.apply( this, arguments );\n\n\tthis.PARTICLE_COUNT = maxParticles || 100000;\n\tthis.PARTICLE_CURSOR = 0;\n\tthis.time = 0;\n\tthis.offset = 0;\n\tthis.count = 0;\n\tthis.DPR = window.devicePixelRatio;\n\tthis.GPUParticleSystem = particleSystem;\n\tthis.particleUpdate = false;\n\n\t// geometry\n\n\tthis.particleShaderGeo = new THREE.BufferGeometry();\n\n\tthis.particleShaderGeo.addAttribute( 'position', new THREE.BufferAttribute( new Float32Array( this.PARTICLE_COUNT * 3 ), 3 ).setDynamic( true ) );\n\tthis.particleShaderGeo.addAttribute( 'positionStart', new THREE.BufferAttribute( new Float32Array( this.PARTICLE_COUNT * 3 ), 3 ).setDynamic( true ) );\n\tthis.particleShaderGeo.addAttribute( 'startTime', new THREE.BufferAttribute( new Float32Array( this.PARTICLE_COUNT ), 1 ).setDynamic( true ) );\n\tthis.particleShaderGeo.addAttribute( 'velocity', new THREE.BufferAttribute( new Float32Array( this.PARTICLE_COUNT * 3 ), 3 ).setDynamic( true ) );\n\tthis.particleShaderGeo.addAttribute( 'turbulence', new THREE.BufferAttribute( new Float32Array( this.PARTICLE_COUNT ), 1 ).setDynamic( true ) );\n\tthis.particleShaderGeo.addAttribute( 'color', new THREE.BufferAttribute( new Float32Array( this.PARTICLE_COUNT * 3 ), 3 ).setDynamic( true ) );\n\tthis.particleShaderGeo.addAttribute( 'size', new THREE.BufferAttribute( new Float32Array( this.PARTICLE_COUNT ), 1 ).setDynamic( true ) );\n\tthis.particleShaderGeo.addAttribute( 'lifeTime', new THREE.BufferAttribute( new Float32Array( this.PARTICLE_COUNT ), 1 ).setDynamic( true ) );\n\n\t// material\n\n\tthis.particleShaderMat = this.GPUParticleSystem.particleShaderMat;\n\n\tvar position = new THREE.Vector3();\n\tvar velocity = new THREE.Vector3();\n\tvar color = new THREE.Color();\n\n\tthis.spawnParticle = function ( options ) {\n\n\t\tvar positionStartAttribute = this.particleShaderGeo.getAttribute( 'positionStart' );\n\t\tvar startTimeAttribute = this.particleShaderGeo.getAttribute( 'startTime' );\n\t\tvar velocityAttribute = this.particleShaderGeo.getAttribute( 'velocity' );\n\t\tvar turbulenceAttribute = this.particleShaderGeo.getAttribute( 'turbulence' );\n\t\tvar colorAttribute = this.particleShaderGeo.getAttribute( 'color' );\n\t\tvar sizeAttribute = this.particleShaderGeo.getAttribute( 'size' );\n\t\tvar lifeTimeAttribute = this.particleShaderGeo.getAttribute( 'lifeTime' );\n\n\t\toptions = options || {};\n\n\t\t// setup reasonable default values for all arguments\n\n\t\tposition = options.position !== undefined ? position.copy( options.position ) : position.set( 0, 0, 0 );\n\t\tvelocity = options.velocity !== undefined ? velocity.copy( options.velocity ) : velocity.set( 0, 0, 0 );\n\t\tcolor = options.color !== undefined ? color.set( options.color ) : color.set( 0xffffff );\n\n\t\tvar positionRandomness = options.positionRandomness !== undefined ? options.positionRandomness : 0;\n\t\tvar velocityRandomness = options.velocityRandomness !== undefined ? options.velocityRandomness : 0;\n\t\tvar colorRandomness = options.colorRandomness !== undefined ? options.colorRandomness : 1;\n\t\tvar turbulence = options.turbulence !== undefined ? options.turbulence : 1;\n\t\tvar lifetime = options.lifetime !== undefined ? options.lifetime : 5;\n\t\tvar size = options.size !== undefined ? options.size : 10;\n\t\tvar sizeRandomness = options.sizeRandomness !== undefined ? options.sizeRandomness : 0;\n\t\tvar smoothPosition = options.smoothPosition !== undefined ? options.smoothPosition : false;\n\n\t\tif ( this.DPR !== undefined ) size *= this.DPR;\n\n\t\tvar i = this.PARTICLE_CURSOR;\n\n\t\t// position\n\n\t\tpositionStartAttribute.array[ i * 3 + 0 ] = position.x + ( particleSystem.random() * positionRandomness );\n\t\tpositionStartAttribute.array[ i * 3 + 1 ] = position.y + ( particleSystem.random() * positionRandomness );\n\t\tpositionStartAttribute.array[ i * 3 + 2 ] = position.z + ( particleSystem.random() * positionRandomness );\n\n\t\tif ( smoothPosition === true ) {\n\n\t\t\tpositionStartAttribute.array[ i * 3 + 0 ] += - ( velocity.x * particleSystem.random() );\n\t\t\tpositionStartAttribute.array[ i * 3 + 1 ] += - ( velocity.y * particleSystem.random() );\n\t\t\tpositionStartAttribute.array[ i * 3 + 2 ] += - ( velocity.z * particleSystem.random() );\n\n\t\t}\n\n\t\t// velocity\n\n\t\tvar maxVel = 2;\n\n\t\tvar velX = velocity.x + particleSystem.random() * velocityRandomness;\n\t\tvar velY = velocity.y + particleSystem.random() * velocityRandomness;\n\t\tvar velZ = velocity.z + particleSystem.random() * velocityRandomness;\n\n\t\tvelX = THREE.Math.clamp( ( velX - ( - maxVel ) ) / ( maxVel - ( - maxVel ) ), 0, 1 );\n\t\tvelY = THREE.Math.clamp( ( velY - ( - maxVel ) ) / ( maxVel - ( - maxVel ) ), 0, 1 );\n\t\tvelZ = THREE.Math.clamp( ( velZ - ( - maxVel ) ) / ( maxVel - ( - maxVel ) ), 0, 1 );\n\n\t\tvelocityAttribute.array[ i * 3 + 0 ] = velX;\n\t\tvelocityAttribute.array[ i * 3 + 1 ] = velY;\n\t\tvelocityAttribute.array[ i * 3 + 2 ] = velZ;\n\n\t\t// color\n\n\t\tcolor.r = THREE.Math.clamp( color.r + particleSystem.random() * colorRandomness, 0, 1 );\n\t\tcolor.g = THREE.Math.clamp( color.g + particleSystem.random() * colorRandomness, 0, 1 );\n\t\tcolor.b = THREE.Math.clamp( color.b + particleSystem.random() * colorRandomness, 0, 1 );\n\n\t\tcolorAttribute.array[ i * 3 + 0 ] = color.r;\n\t\tcolorAttribute.array[ i * 3 + 1 ] = color.g;\n\t\tcolorAttribute.array[ i * 3 + 2 ] = color.b;\n\n\t\t// turbulence, size, lifetime and starttime\n\n\t\tturbulenceAttribute.array[ i ] = turbulence;\n\t\tsizeAttribute.array[ i ] = size + particleSystem.random() * sizeRandomness;\n\t\tlifeTimeAttribute.array[ i ] = lifetime;\n\t\tstartTimeAttribute.array[ i ] = this.time + particleSystem.random() * 2e-2;\n\n\t\t// offset\n\n\t\tif ( this.offset === 0 ) {\n\n\t\t\tthis.offset = this.PARTICLE_CURSOR;\n\n\t\t}\n\n\t\t// counter and cursor\n\n\t\tthis.count ++;\n\t\tthis.PARTICLE_CURSOR ++;\n\n\t\tif ( this.PARTICLE_CURSOR >= this.PARTICLE_COUNT ) {\n\n\t\t\tthis.PARTICLE_CURSOR = 0;\n\n\t\t}\n\n\t\tthis.particleUpdate = true;\n\n\t};\n\n\tthis.init = function () {\n\n\t\tthis.particleSystem = new THREE.Points( this.particleShaderGeo, this.particleShaderMat );\n\t\tthis.particleSystem.frustumCulled = false;\n\t\tthis.add( this.particleSystem );\n\n\t};\n\n\tthis.update = function ( time ) {\n\n\t\tthis.time = time;\n\t\tthis.particleShaderMat.uniforms.uTime.value = time;\n\n\t\tthis.geometryUpdate();\n\n\t};\n\n\tthis.geometryUpdate = function () {\n\n\t\tif ( this.particleUpdate === true ) {\n\n\t\t\tthis.particleUpdate = false;\n\n\t\t\tvar positionStartAttribute = this.particleShaderGeo.getAttribute( 'positionStart' );\n\t\t\tvar startTimeAttribute = this.particleShaderGeo.getAttribute( 'startTime' );\n\t\t\tvar velocityAttribute = this.particleShaderGeo.getAttribute( 'velocity' );\n\t\t\tvar turbulenceAttribute = this.particleShaderGeo.getAttribute( 'turbulence' );\n\t\t\tvar colorAttribute = this.particleShaderGeo.getAttribute( 'color' );\n\t\t\tvar sizeAttribute = this.particleShaderGeo.getAttribute( 'size' );\n\t\t\tvar lifeTimeAttribute = this.particleShaderGeo.getAttribute( 'lifeTime' );\n\n\t\t\tif ( this.offset + this.count < this.PARTICLE_COUNT ) {\n\n\t\t\t\tpositionStartAttribute.updateRange.offset = this.offset * positionStartAttribute.itemSize;\n\t\t\t\tstartTimeAttribute.updateRange.offset = this.offset * startTimeAttribute.itemSize;\n\t\t\t\tvelocityAttribute.updateRange.offset = this.offset * velocityAttribute.itemSize;\n\t\t\t\tturbulenceAttribute.updateRange.offset = this.offset * turbulenceAttribute.itemSize;\n\t\t\t\tcolorAttribute.updateRange.offset = this.offset * colorAttribute.itemSize;\n\t\t\t\tsizeAttribute.updateRange.offset = this.offset * sizeAttribute.itemSize;\n\t\t\t\tlifeTimeAttribute.updateRange.offset = this.offset * lifeTimeAttribute.itemSize;\n\n\t\t\t\tpositionStartAttribute.updateRange.count = this.count * positionStartAttribute.itemSize;\n\t\t\t\tstartTimeAttribute.updateRange.count = this.count * startTimeAttribute.itemSize;\n\t\t\t\tvelocityAttribute.updateRange.count = this.count * velocityAttribute.itemSize;\n\t\t\t\tturbulenceAttribute.updateRange.count = this.count * turbulenceAttribute.itemSize;\n\t\t\t\tcolorAttribute.updateRange.count = this.count * colorAttribute.itemSize;\n\t\t\t\tsizeAttribute.updateRange.count = this.count * sizeAttribute.itemSize;\n\t\t\t\tlifeTimeAttribute.updateRange.count = this.count * lifeTimeAttribute.itemSize;\n\n\t\t\t} else {\n\n\t\t\t\tpositionStartAttribute.updateRange.offset = 0;\n\t\t\t\tstartTimeAttribute.updateRange.offset = 0;\n\t\t\t\tvelocityAttribute.updateRange.offset = 0;\n\t\t\t\tturbulenceAttribute.updateRange.offset = 0;\n\t\t\t\tcolorAttribute.updateRange.offset = 0;\n\t\t\t\tsizeAttribute.updateRange.offset = 0;\n\t\t\t\tlifeTimeAttribute.updateRange.offset = 0;\n\n\t\t\t\t// Use -1 to update the entire buffer, see #11476\n\t\t\t\tpositionStartAttribute.updateRange.count = - 1;\n\t\t\t\tstartTimeAttribute.updateRange.count = - 1;\n\t\t\t\tvelocityAttribute.updateRange.count = - 1;\n\t\t\t\tturbulenceAttribute.updateRange.count = - 1;\n\t\t\t\tcolorAttribute.updateRange.count = - 1;\n\t\t\t\tsizeAttribute.updateRange.count = - 1;\n\t\t\t\tlifeTimeAttribute.updateRange.count = - 1;\n\n\t\t\t}\n\n\t\t\tpositionStartAttribute.needsUpdate = true;\n\t\t\tstartTimeAttribute.needsUpdate = true;\n\t\t\tvelocityAttribute.needsUpdate = true;\n\t\t\tturbulenceAttribute.needsUpdate = true;\n\t\t\tcolorAttribute.needsUpdate = true;\n\t\t\tsizeAttribute.needsUpdate = true;\n\t\t\tlifeTimeAttribute.needsUpdate = true;\n\n\t\t\tthis.offset = 0;\n\t\t\tthis.count = 0;\n\n\t\t}\n\n\t};\n\n\tthis.dispose = function () {\n\n\t\tthis.particleShaderGeo.dispose();\n\n\t};\n\n\tthis.init();\n\n};\n\nGPUParticleContainer.prototype = Object.create( THREE.Object3D.prototype );\nGPUParticleContainer.prototype.constructor = GPUParticleContainer;\n\nexport default GPUParticleSystem;"]},"metadata":{},"sourceType":"module"}