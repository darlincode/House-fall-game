{"ast":null,"code":"import * as THREE from 'three';\nimport DDSLoader from \"./dds-loader\";\n/**\n * @author Rich Tibbett / https://github.com/richtr\n * @author mrdoob / http://mrdoob.com/\n * @author Tony Parisi / http://www.tonyparisi.com/\n * @author Takahiro / https://github.com/takahirox\n * @author Don McCurdy / https://www.donmccurdy.com\n */\n\nvar GLTFLoader = function () {\n  function GLTFLoader(manager) {\n    this.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;\n    this.dracoLoader = null;\n  }\n\n  GLTFLoader.prototype = {\n    constructor: GLTFLoader,\n    crossOrigin: 'Anonymous',\n    load: function load(url, onLoad, onProgress, onError) {\n      var scope = this;\n      var path = this.path !== undefined ? this.path : THREE.LoaderUtils.extractUrlBase(url);\n      var loader = new THREE.FileLoader(scope.manager);\n      loader.setResponseType('arraybuffer');\n      loader.load(url, function (data) {\n        try {\n          scope.parse(data, path, onLoad, onError);\n        } catch (e) {\n          if (onError !== undefined) {\n            onError(e);\n          } else {\n            throw e;\n          }\n        }\n      }, onProgress, onError);\n    },\n    setCrossOrigin: function setCrossOrigin(value) {\n      this.crossOrigin = value;\n      return this;\n    },\n    setPath: function setPath(value) {\n      this.path = value;\n      return this;\n    },\n    setDRACOLoader: function setDRACOLoader(dracoLoader) {\n      this.dracoLoader = dracoLoader;\n      return this;\n    },\n    parse: function parse(data, path, onLoad, onError) {\n      var content;\n      var extensions = {};\n\n      if (typeof data === 'string') {\n        content = data;\n      } else {\n        var magic = THREE.LoaderUtils.decodeText(new Uint8Array(data, 0, 4));\n\n        if (magic === BINARY_EXTENSION_HEADER_MAGIC) {\n          try {\n            extensions[EXTENSIONS.KHR_BINARY_GLTF] = new GLTFBinaryExtension(data);\n          } catch (error) {\n            if (onError) onError(error);\n            return;\n          }\n\n          content = extensions[EXTENSIONS.KHR_BINARY_GLTF].content;\n        } else {\n          content = THREE.LoaderUtils.decodeText(new Uint8Array(data));\n        }\n      }\n\n      var json = JSON.parse(content);\n\n      if (json.asset === undefined || json.asset.version[0] < 2) {\n        if (onError) onError(new Error('THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported. Use LegacyGLTFLoader instead.'));\n        return;\n      }\n\n      if (json.extensionsUsed) {\n        if (json.extensionsUsed.indexOf(EXTENSIONS.KHR_LIGHTS) >= 0) {\n          extensions[EXTENSIONS.KHR_LIGHTS] = new GLTFLightsExtension(json);\n        }\n\n        if (json.extensionsUsed.indexOf(EXTENSIONS.KHR_MATERIALS_UNLIT) >= 0) {\n          extensions[EXTENSIONS.KHR_MATERIALS_UNLIT] = new GLTFMaterialsUnlitExtension(json);\n        }\n\n        if (json.extensionsUsed.indexOf(EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS) >= 0) {\n          extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS] = new GLTFMaterialsPbrSpecularGlossinessExtension();\n        }\n\n        if (json.extensionsUsed.indexOf(EXTENSIONS.KHR_DRACO_MESH_COMPRESSION) >= 0) {\n          extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION] = new GLTFDracoMeshCompressionExtension(this.dracoLoader);\n        }\n\n        if (json.extensionsUsed.indexOf(EXTENSIONS.MSFT_TEXTURE_DDS) >= 0) {\n          extensions[EXTENSIONS.MSFT_TEXTURE_DDS] = new GLTFTextureDDSExtension();\n        }\n      }\n\n      var parser = new GLTFParser(json, extensions, {\n        path: path || this.path || '',\n        crossOrigin: this.crossOrigin,\n        manager: this.manager\n      });\n      parser.parse(function (scene, scenes, cameras, animations, asset) {\n        var glTF = {\n          scene: scene,\n          scenes: scenes,\n          cameras: cameras,\n          animations: animations,\n          asset: asset\n        };\n        onLoad(glTF);\n      }, onError);\n    }\n  };\n  /* GLTFREGISTRY */\n\n  function GLTFRegistry() {\n    var objects = {};\n    return {\n      get: function get(key) {\n        return objects[key];\n      },\n      add: function add(key, object) {\n        objects[key] = object;\n      },\n      remove: function remove(key) {\n        delete objects[key];\n      },\n      removeAll: function removeAll() {\n        objects = {};\n      }\n    };\n  }\n  /*********************************/\n\n  /********** EXTENSIONS ***********/\n\n  /*********************************/\n\n\n  var EXTENSIONS = {\n    KHR_BINARY_GLTF: 'KHR_binary_glTF',\n    KHR_DRACO_MESH_COMPRESSION: 'KHR_draco_mesh_compression',\n    KHR_LIGHTS: 'KHR_lights',\n    KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: 'KHR_materials_pbrSpecularGlossiness',\n    KHR_MATERIALS_UNLIT: 'KHR_materials_unlit',\n    MSFT_TEXTURE_DDS: 'MSFT_texture_dds'\n  };\n  /**\n   * DDS Texture Extension\n   *\n   * Specification: \n   * https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/MSFT_texture_dds\n   * \n   */\n\n  function GLTFTextureDDSExtension() {\n    if (!DDSLoader) {\n      throw new Error('THREE.GLTFLoader: Attempting to load .dds texture without importing THREE.DDSLoader');\n    }\n\n    this.name = EXTENSIONS.MSFT_TEXTURE_DDS;\n    this.ddsLoader = new DDSLoader();\n  }\n  /**\n   * Lights Extension\n   *\n   * Specification: PENDING\n   */\n\n\n  function GLTFLightsExtension(json) {\n    this.name = EXTENSIONS.KHR_LIGHTS;\n    this.lights = {};\n    var extension = json.extensions && json.extensions[EXTENSIONS.KHR_LIGHTS] || {};\n    var lights = extension.lights || {};\n\n    for (var lightId in lights) {\n      var light = lights[lightId];\n      var lightNode;\n      var color = new THREE.Color().fromArray(light.color);\n\n      switch (light.type) {\n        case 'directional':\n          lightNode = new THREE.DirectionalLight(color);\n          lightNode.target.position.set(0, 0, 1);\n          lightNode.add(lightNode.target);\n          break;\n\n        case 'point':\n          lightNode = new THREE.PointLight(color);\n          break;\n\n        case 'spot':\n          lightNode = new THREE.SpotLight(color); // Handle spotlight properties.\n\n          light.spot = light.spot || {};\n          light.spot.innerConeAngle = light.spot.innerConeAngle !== undefined ? light.spot.innerConeAngle : 0;\n          light.spot.outerConeAngle = light.spot.outerConeAngle !== undefined ? light.spot.outerConeAngle : Math.PI / 4.0;\n          lightNode.angle = light.spot.outerConeAngle;\n          lightNode.penumbra = 1.0 - light.spot.innerConeAngle / light.spot.outerConeAngle;\n          lightNode.target.position.set(0, 0, 1);\n          lightNode.add(lightNode.target);\n          break;\n\n        case 'ambient':\n          lightNode = new THREE.AmbientLight(color);\n          break;\n\n        default:\n      }\n\n      if (lightNode) {\n        lightNode.decay = 2;\n\n        if (light.intensity !== undefined) {\n          lightNode.intensity = light.intensity;\n        }\n\n        lightNode.name = light.name || 'light_' + lightId;\n        this.lights[lightId] = lightNode;\n      }\n    }\n  }\n  /**\n   * Unlit Materials Extension (pending)\n   *\n   * PR: https://github.com/KhronosGroup/glTF/pull/1163\n   */\n\n\n  function GLTFMaterialsUnlitExtension(json) {\n    this.name = EXTENSIONS.KHR_MATERIALS_UNLIT;\n  }\n\n  GLTFMaterialsUnlitExtension.prototype.getMaterialType = function (material) {\n    return THREE.MeshBasicMaterial;\n  };\n\n  GLTFMaterialsUnlitExtension.prototype.extendParams = function (materialParams, material, parser) {\n    var pending = [];\n    materialParams.color = new THREE.Color(1.0, 1.0, 1.0);\n    materialParams.opacity = 1.0;\n    var metallicRoughness = material.pbrMetallicRoughness;\n\n    if (metallicRoughness) {\n      if (Array.isArray(metallicRoughness.baseColorFactor)) {\n        var array = metallicRoughness.baseColorFactor;\n        materialParams.color.fromArray(array);\n        materialParams.opacity = array[3];\n      }\n\n      if (metallicRoughness.baseColorTexture !== undefined) {\n        pending.push(parser.assignTexture(materialParams, 'map', metallicRoughness.baseColorTexture.index));\n      }\n    }\n\n    return Promise.all(pending);\n  };\n  /* BINARY EXTENSION */\n\n\n  var BINARY_EXTENSION_HEADER_MAGIC = 'glTF';\n  var BINARY_EXTENSION_HEADER_LENGTH = 12;\n  var BINARY_EXTENSION_CHUNK_TYPES = {\n    JSON: 0x4E4F534A,\n    BIN: 0x004E4942\n  };\n\n  function GLTFBinaryExtension(data) {\n    this.name = EXTENSIONS.KHR_BINARY_GLTF;\n    this.content = null;\n    this.body = null;\n    var headerView = new DataView(data, 0, BINARY_EXTENSION_HEADER_LENGTH);\n    this.header = {\n      magic: THREE.LoaderUtils.decodeText(new Uint8Array(data.slice(0, 4))),\n      version: headerView.getUint32(4, true),\n      length: headerView.getUint32(8, true)\n    };\n\n    if (this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC) {\n      throw new Error('THREE.GLTFLoader: Unsupported glTF-Binary header.');\n    } else if (this.header.version < 2.0) {\n      throw new Error('THREE.GLTFLoader: Legacy binary file detected. Use LegacyGLTFLoader instead.');\n    }\n\n    var chunkView = new DataView(data, BINARY_EXTENSION_HEADER_LENGTH);\n    var chunkIndex = 0;\n\n    while (chunkIndex < chunkView.byteLength) {\n      var chunkLength = chunkView.getUint32(chunkIndex, true);\n      chunkIndex += 4;\n      var chunkType = chunkView.getUint32(chunkIndex, true);\n      chunkIndex += 4;\n\n      if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON) {\n        var contentArray = new Uint8Array(data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength);\n        this.content = THREE.LoaderUtils.decodeText(contentArray);\n      } else if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN) {\n        var byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;\n        this.body = data.slice(byteOffset, byteOffset + chunkLength);\n      } // Clients must ignore chunks with unknown types.\n\n\n      chunkIndex += chunkLength;\n    }\n\n    if (this.content === null) {\n      throw new Error('THREE.GLTFLoader: JSON content not found.');\n    }\n  }\n  /**\n   * DRACO Mesh Compression Extension\n   *\n   * Specification: https://github.com/KhronosGroup/glTF/pull/874\n   */\n\n\n  function GLTFDracoMeshCompressionExtension(dracoLoader) {\n    if (!dracoLoader) {\n      throw new Error('THREE.GLTFLoader: No DRACOLoader instance provided.');\n    }\n\n    this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;\n    this.dracoLoader = dracoLoader;\n  }\n\n  GLTFDracoMeshCompressionExtension.prototype.decodePrimitive = function (primitive, parser) {\n    var dracoLoader = this.dracoLoader;\n    var bufferViewIndex = primitive.extensions[this.name].bufferView;\n    var gltfAttributeMap = primitive.extensions[this.name].attributes;\n    var threeAttributeMap = {};\n\n    for (var attributeName in gltfAttributeMap) {\n      if (!(attributeName in ATTRIBUTES)) continue;\n      threeAttributeMap[ATTRIBUTES[attributeName]] = gltfAttributeMap[attributeName];\n    }\n\n    return parser.getDependency('bufferView', bufferViewIndex).then(function (bufferView) {\n      return new Promise(function (resolve) {\n        dracoLoader.decodeDracoFile(bufferView, resolve, threeAttributeMap);\n      });\n    });\n  };\n  /**\n   * Specular-Glossiness Extension\n   *\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness\n   */\n\n\n  function GLTFMaterialsPbrSpecularGlossinessExtension() {\n    return {\n      name: EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS,\n      specularGlossinessParams: ['color', 'map', 'lightMap', 'lightMapIntensity', 'aoMap', 'aoMapIntensity', 'emissive', 'emissiveIntensity', 'emissiveMap', 'bumpMap', 'bumpScale', 'normalMap', 'displacementMap', 'displacementScale', 'displacementBias', 'specularMap', 'specular', 'glossinessMap', 'glossiness', 'alphaMap', 'envMap', 'envMapIntensity', 'refractionRatio'],\n      getMaterialType: function getMaterialType() {\n        return THREE.ShaderMaterial;\n      },\n      extendParams: function extendParams(params, material, parser) {\n        var pbrSpecularGlossiness = material.extensions[this.name];\n        var shader = THREE.ShaderLib['standard'];\n        var uniforms = THREE.UniformsUtils.clone(shader.uniforms);\n        var specularMapParsFragmentChunk = ['#ifdef USE_SPECULARMAP', '\tuniform sampler2D specularMap;', '#endif'].join('\\n');\n        var glossinessMapParsFragmentChunk = ['#ifdef USE_GLOSSINESSMAP', '\tuniform sampler2D glossinessMap;', '#endif'].join('\\n');\n        var specularMapFragmentChunk = ['vec3 specularFactor = specular;', '#ifdef USE_SPECULARMAP', '\tvec4 texelSpecular = texture2D( specularMap, vUv );', '\ttexelSpecular = sRGBToLinear( texelSpecular );', '\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture', '\tspecularFactor *= texelSpecular.rgb;', '#endif'].join('\\n');\n        var glossinessMapFragmentChunk = ['float glossinessFactor = glossiness;', '#ifdef USE_GLOSSINESSMAP', '\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );', '\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture', '\tglossinessFactor *= texelGlossiness.a;', '#endif'].join('\\n');\n        var lightPhysicalFragmentChunk = ['PhysicalMaterial material;', 'material.diffuseColor = diffuseColor.rgb;', 'material.specularRoughness = clamp( 1.0 - glossinessFactor, 0.04, 1.0 );', 'material.specularColor = specularFactor.rgb;'].join('\\n');\n        var fragmentShader = shader.fragmentShader.replace('#include <specularmap_fragment>', '').replace('uniform float roughness;', 'uniform vec3 specular;').replace('uniform float metalness;', 'uniform float glossiness;').replace('#include <roughnessmap_pars_fragment>', specularMapParsFragmentChunk).replace('#include <metalnessmap_pars_fragment>', glossinessMapParsFragmentChunk).replace('#include <roughnessmap_fragment>', specularMapFragmentChunk).replace('#include <metalnessmap_fragment>', glossinessMapFragmentChunk).replace('#include <lights_physical_fragment>', lightPhysicalFragmentChunk);\n        delete uniforms.roughness;\n        delete uniforms.metalness;\n        delete uniforms.roughnessMap;\n        delete uniforms.metalnessMap;\n        uniforms.specular = {\n          value: new THREE.Color().setHex(0x111111)\n        };\n        uniforms.glossiness = {\n          value: 0.5\n        };\n        uniforms.specularMap = {\n          value: null\n        };\n        uniforms.glossinessMap = {\n          value: null\n        };\n        params.vertexShader = shader.vertexShader;\n        params.fragmentShader = fragmentShader;\n        params.uniforms = uniforms;\n        params.defines = {\n          'STANDARD': ''\n        };\n        params.color = new THREE.Color(1.0, 1.0, 1.0);\n        params.opacity = 1.0;\n        var pending = [];\n\n        if (Array.isArray(pbrSpecularGlossiness.diffuseFactor)) {\n          var array = pbrSpecularGlossiness.diffuseFactor;\n          params.color.fromArray(array);\n          params.opacity = array[3];\n        }\n\n        if (pbrSpecularGlossiness.diffuseTexture !== undefined) {\n          pending.push(parser.assignTexture(params, 'map', pbrSpecularGlossiness.diffuseTexture.index));\n        }\n\n        params.emissive = new THREE.Color(0.0, 0.0, 0.0);\n        params.glossiness = pbrSpecularGlossiness.glossinessFactor !== undefined ? pbrSpecularGlossiness.glossinessFactor : 1.0;\n        params.specular = new THREE.Color(1.0, 1.0, 1.0);\n\n        if (Array.isArray(pbrSpecularGlossiness.specularFactor)) {\n          params.specular.fromArray(pbrSpecularGlossiness.specularFactor);\n        }\n\n        if (pbrSpecularGlossiness.specularGlossinessTexture !== undefined) {\n          var specGlossIndex = pbrSpecularGlossiness.specularGlossinessTexture.index;\n          pending.push(parser.assignTexture(params, 'glossinessMap', specGlossIndex));\n          pending.push(parser.assignTexture(params, 'specularMap', specGlossIndex));\n        }\n\n        return Promise.all(pending);\n      },\n      createMaterial: function createMaterial(params) {\n        // setup material properties based on MeshStandardMaterial for Specular-Glossiness\n        var material = new THREE.ShaderMaterial({\n          defines: params.defines,\n          vertexShader: params.vertexShader,\n          fragmentShader: params.fragmentShader,\n          uniforms: params.uniforms,\n          fog: true,\n          lights: true,\n          opacity: params.opacity,\n          transparent: params.transparent\n        });\n        material.isGLTFSpecularGlossinessMaterial = true;\n        material.color = params.color;\n        material.map = params.map === undefined ? null : params.map;\n        material.lightMap = null;\n        material.lightMapIntensity = 1.0;\n        material.aoMap = params.aoMap === undefined ? null : params.aoMap;\n        material.aoMapIntensity = 1.0;\n        material.emissive = params.emissive;\n        material.emissiveIntensity = 1.0;\n        material.emissiveMap = params.emissiveMap === undefined ? null : params.emissiveMap;\n        material.bumpMap = params.bumpMap === undefined ? null : params.bumpMap;\n        material.bumpScale = 1;\n        material.normalMap = params.normalMap === undefined ? null : params.normalMap;\n        if (params.normalScale) material.normalScale = params.normalScale;\n        material.displacementMap = null;\n        material.displacementScale = 1;\n        material.displacementBias = 0;\n        material.specularMap = params.specularMap === undefined ? null : params.specularMap;\n        material.specular = params.specular;\n        material.glossinessMap = params.glossinessMap === undefined ? null : params.glossinessMap;\n        material.glossiness = params.glossiness;\n        material.alphaMap = null;\n        material.envMap = params.envMap === undefined ? null : params.envMap;\n        material.envMapIntensity = 1.0;\n        material.refractionRatio = 0.98;\n        material.extensions.derivatives = true;\n        return material;\n      },\n\n      /**\n       * Clones a GLTFSpecularGlossinessMaterial instance. The ShaderMaterial.copy() method can\n       * copy only properties it knows about or inherits, and misses many properties that would\n       * normally be defined by MeshStandardMaterial.\n       *\n       * This method allows GLTFSpecularGlossinessMaterials to be cloned in the process of\n       * loading a glTF model, but cloning later (e.g. by the user) would require these changes\n       * AND also updating `.onBeforeRender` on the parent mesh.\n       *\n       * @param  {THREE.ShaderMaterial} source\n       * @return {THREE.ShaderMaterial}\n       */\n      cloneMaterial: function cloneMaterial(source) {\n        var target = source.clone();\n        target.isGLTFSpecularGlossinessMaterial = true;\n        var params = this.specularGlossinessParams;\n\n        for (var i = 0, il = params.length; i < il; i++) {\n          target[params[i]] = source[params[i]];\n        }\n\n        return target;\n      },\n      // Here's based on refreshUniformsCommon() and refreshUniformsStandard() in WebGLRenderer.\n      refreshUniforms: function refreshUniforms(renderer, scene, camera, geometry, material, group) {\n        if (material.isGLTFSpecularGlossinessMaterial !== true) {\n          return;\n        }\n\n        var uniforms = material.uniforms;\n        var defines = material.defines;\n        uniforms.opacity.value = material.opacity;\n        uniforms.diffuse.value.copy(material.color);\n        uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);\n        uniforms.map.value = material.map;\n        uniforms.specularMap.value = material.specularMap;\n        uniforms.alphaMap.value = material.alphaMap;\n        uniforms.lightMap.value = material.lightMap;\n        uniforms.lightMapIntensity.value = material.lightMapIntensity;\n        uniforms.aoMap.value = material.aoMap;\n        uniforms.aoMapIntensity.value = material.aoMapIntensity; // uv repeat and offset setting priorities\n        // 1. color map\n        // 2. specular map\n        // 3. normal map\n        // 4. bump map\n        // 5. alpha map\n        // 6. emissive map\n\n        var uvScaleMap;\n\n        if (material.map) {\n          uvScaleMap = material.map;\n        } else if (material.specularMap) {\n          uvScaleMap = material.specularMap;\n        } else if (material.displacementMap) {\n          uvScaleMap = material.displacementMap;\n        } else if (material.normalMap) {\n          uvScaleMap = material.normalMap;\n        } else if (material.bumpMap) {\n          uvScaleMap = material.bumpMap;\n        } else if (material.glossinessMap) {\n          uvScaleMap = material.glossinessMap;\n        } else if (material.alphaMap) {\n          uvScaleMap = material.alphaMap;\n        } else if (material.emissiveMap) {\n          uvScaleMap = material.emissiveMap;\n        }\n\n        if (uvScaleMap !== undefined) {\n          // backwards compatibility\n          if (uvScaleMap.isWebGLRenderTarget) {\n            uvScaleMap = uvScaleMap.texture;\n          }\n\n          var offset;\n          var repeat;\n\n          if (uvScaleMap.matrix !== undefined) {\n            // > r88.\n            if (uvScaleMap.matrixAutoUpdate === true) {\n              offset = uvScaleMap.offset;\n              repeat = uvScaleMap.repeat;\n              var rotation = uvScaleMap.rotation;\n              var center = uvScaleMap.center;\n              uvScaleMap.matrix.setUvTransform(offset.x, offset.y, repeat.x, repeat.y, rotation, center.x, center.y);\n            }\n\n            uniforms.uvTransform.value.copy(uvScaleMap.matrix);\n          } else {\n            // <= r87. Remove when reasonable.\n            offset = uvScaleMap.offset;\n            repeat = uvScaleMap.repeat;\n            uniforms.offsetRepeat.value.set(offset.x, offset.y, repeat.x, repeat.y);\n          }\n        }\n\n        uniforms.envMap.value = material.envMap;\n        uniforms.envMapIntensity.value = material.envMapIntensity;\n        uniforms.flipEnvMap.value = material.envMap && material.envMap.isCubeTexture ? -1 : 1;\n        uniforms.refractionRatio.value = material.refractionRatio;\n        uniforms.specular.value.copy(material.specular);\n        uniforms.glossiness.value = material.glossiness;\n        uniforms.glossinessMap.value = material.glossinessMap;\n        uniforms.emissiveMap.value = material.emissiveMap;\n        uniforms.bumpMap.value = material.bumpMap;\n        uniforms.normalMap.value = material.normalMap;\n        uniforms.displacementMap.value = material.displacementMap;\n        uniforms.displacementScale.value = material.displacementScale;\n        uniforms.displacementBias.value = material.displacementBias;\n\n        if (uniforms.glossinessMap.value !== null && defines.USE_GLOSSINESSMAP === undefined) {\n          defines.USE_GLOSSINESSMAP = ''; // set USE_ROUGHNESSMAP to enable vUv\n\n          defines.USE_ROUGHNESSMAP = '';\n        }\n\n        if (uniforms.glossinessMap.value === null && defines.USE_GLOSSINESSMAP !== undefined) {\n          delete defines.USE_GLOSSINESSMAP;\n          delete defines.USE_ROUGHNESSMAP;\n        }\n      }\n    };\n  }\n  /*********************************/\n\n  /********** INTERPOLATION ********/\n\n  /*********************************/\n  // Spline Interpolation\n  // Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#appendix-c-spline-interpolation\n\n\n  function GLTFCubicSplineInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {\n    THREE.Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);\n  }\n\n  ;\n  GLTFCubicSplineInterpolant.prototype = Object.create(THREE.Interpolant.prototype);\n  GLTFCubicSplineInterpolant.prototype.constructor = GLTFCubicSplineInterpolant;\n\n  GLTFCubicSplineInterpolant.prototype.interpolate_ = function (i1, t0, t, t1) {\n    var result = this.resultBuffer;\n    var values = this.sampleValues;\n    var stride = this.valueSize;\n    var stride2 = stride * 2;\n    var stride3 = stride * 3;\n    var td = t1 - t0;\n    var p = (t - t0) / td;\n    var pp = p * p;\n    var ppp = pp * p;\n    var offset1 = i1 * stride3;\n    var offset0 = offset1 - stride3;\n    var s0 = 2 * ppp - 3 * pp + 1;\n    var s1 = ppp - 2 * pp + p;\n    var s2 = -2 * ppp + 3 * pp;\n    var s3 = ppp - pp; // Layout of keyframe output values for CUBICSPLINE animations:\n    //   [ inTangent_1, splineVertex_1, outTangent_1, inTangent_2, splineVertex_2, ... ]\n\n    for (var i = 0; i !== stride; i++) {\n      var p0 = values[offset0 + i + stride]; // splineVertex_k\n\n      var m0 = values[offset0 + i + stride2] * td; // outTangent_k * (t_k+1 - t_k)\n\n      var p1 = values[offset1 + i + stride]; // splineVertex_k+1\n\n      var m1 = values[offset1 + i] * td; // inTangent_k+1 * (t_k+1 - t_k)\n\n      result[i] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;\n    }\n\n    return result;\n  };\n  /*********************************/\n\n  /********** INTERNALS ************/\n\n  /*********************************/\n\n  /* CONSTANTS */\n\n\n  var WEBGL_CONSTANTS = {\n    FLOAT: 5126,\n    //FLOAT_MAT2: 35674,\n    FLOAT_MAT3: 35675,\n    FLOAT_MAT4: 35676,\n    FLOAT_VEC2: 35664,\n    FLOAT_VEC3: 35665,\n    FLOAT_VEC4: 35666,\n    LINEAR: 9729,\n    REPEAT: 10497,\n    SAMPLER_2D: 35678,\n    POINTS: 0,\n    LINES: 1,\n    LINE_LOOP: 2,\n    LINE_STRIP: 3,\n    TRIANGLES: 4,\n    TRIANGLE_STRIP: 5,\n    TRIANGLE_FAN: 6,\n    UNSIGNED_BYTE: 5121,\n    UNSIGNED_SHORT: 5123\n  };\n  var WEBGL_COMPONENT_TYPES = {\n    5120: Int8Array,\n    5121: Uint8Array,\n    5122: Int16Array,\n    5123: Uint16Array,\n    5125: Uint32Array,\n    5126: Float32Array\n  };\n  var WEBGL_FILTERS = {\n    9728: THREE.NearestFilter,\n    9729: THREE.LinearFilter,\n    9984: THREE.NearestMipMapNearestFilter,\n    9985: THREE.LinearMipMapNearestFilter,\n    9986: THREE.NearestMipMapLinearFilter,\n    9987: THREE.LinearMipMapLinearFilter\n  };\n  var WEBGL_WRAPPINGS = {\n    33071: THREE.ClampToEdgeWrapping,\n    33648: THREE.MirroredRepeatWrapping,\n    10497: THREE.RepeatWrapping\n  };\n  var WEBGL_TEXTURE_FORMATS = {\n    6406: THREE.AlphaFormat,\n    6407: THREE.RGBFormat,\n    6408: THREE.RGBAFormat,\n    6409: THREE.LuminanceFormat,\n    6410: THREE.LuminanceAlphaFormat\n  };\n  var WEBGL_TEXTURE_DATATYPES = {\n    5121: THREE.UnsignedByteType,\n    32819: THREE.UnsignedShort4444Type,\n    32820: THREE.UnsignedShort5551Type,\n    33635: THREE.UnsignedShort565Type\n  };\n  var WEBGL_TYPE_SIZES = {\n    'SCALAR': 1,\n    'VEC2': 2,\n    'VEC3': 3,\n    'VEC4': 4,\n    'MAT2': 4,\n    'MAT3': 9,\n    'MAT4': 16\n  };\n  var ATTRIBUTES = {\n    POSITION: 'position',\n    NORMAL: 'normal',\n    TEXCOORD_0: 'uv',\n    TEXCOORD0: 'uv',\n    // deprecated\n    TEXCOORD: 'uv',\n    // deprecated\n    TEXCOORD_1: 'uv2',\n    COLOR_0: 'color',\n    COLOR0: 'color',\n    // deprecated\n    COLOR: 'color',\n    // deprecated\n    WEIGHTS_0: 'skinWeight',\n    WEIGHT: 'skinWeight',\n    // deprecated\n    JOINTS_0: 'skinIndex',\n    JOINT: 'skinIndex' // deprecated\n\n  };\n  var PATH_PROPERTIES = {\n    scale: 'scale',\n    translation: 'position',\n    rotation: 'quaternion',\n    weights: 'morphTargetInfluences'\n  };\n  var INTERPOLATION = {\n    CUBICSPLINE: THREE.InterpolateSmooth,\n    // We use custom interpolation GLTFCubicSplineInterpolation for CUBICSPLINE.\n    // KeyframeTrack.optimize() can't handle glTF Cubic Spline output values layout,\n    // using THREE.InterpolateSmooth for KeyframeTrack instantiation to prevent optimization.\n    // See KeyframeTrack.optimize() for the detail.\n    LINEAR: THREE.InterpolateLinear,\n    STEP: THREE.InterpolateDiscrete\n  };\n  var ALPHA_MODES = {\n    OPAQUE: 'OPAQUE',\n    MASK: 'MASK',\n    BLEND: 'BLEND'\n  };\n  /* UTILITY FUNCTIONS */\n\n  function resolveURL(url, path) {\n    // Invalid URL\n    if (typeof url !== 'string' || url === '') return ''; // Absolute URL http://,https://,//\n\n    if (/^(https?:)?\\/\\//i.test(url)) return url; // Data URI\n\n    if (/^data:.*,.*$/i.test(url)) return url; // Blob URL\n\n    if (/^blob:.*$/i.test(url)) return url; // Relative URL\n\n    return path + url;\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#default-material\n   */\n\n\n  function createDefaultMaterial() {\n    return new THREE.MeshStandardMaterial({\n      color: 0xFFFFFF,\n      emissive: 0x000000,\n      metalness: 1,\n      roughness: 1,\n      transparent: false,\n      depthTest: true,\n      side: THREE.FrontSide\n    });\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#morph-targets\n   *\n   * @param {THREE.Mesh} mesh\n   * @param {GLTF.Mesh} meshDef\n   * @param {GLTF.Primitive} primitiveDef\n   * @param {Array<THREE.BufferAttribute>} accessors\n   */\n\n\n  function addMorphTargets(mesh, meshDef, primitiveDef, accessors) {\n    var geometry = mesh.geometry;\n    var targets = primitiveDef.targets;\n    var hasMorphPosition = false;\n    var hasMorphNormal = false;\n    var target = null;\n\n    for (var _i = 0, _il = targets.length; _i < _il; _i++) {\n      target = targets[_i];\n      if (target.POSITION !== undefined) hasMorphPosition = true;\n      if (target.NORMAL !== undefined) hasMorphNormal = true;\n      if (hasMorphPosition && hasMorphNormal) break;\n    }\n\n    if (!hasMorphPosition && !hasMorphNormal) return;\n    var morphPositions = [];\n    var morphNormals = [];\n\n    for (var _i2 = 0, _il2 = targets.length; _i2 < _il2; _i2++) {\n      target = targets[_i2];\n      var attributeName = 'morphTarget' + _i2;\n\n      if (hasMorphPosition) {\n        // Three.js morph position is absolute value. The formula is\n        //   basePosition\n        //     + weight0 * ( morphPosition0 - basePosition )\n        //     + weight1 * ( morphPosition1 - basePosition )\n        //     ...\n        // while the glTF one is relative\n        //   basePosition\n        //     + weight0 * glTFmorphPosition0\n        //     + weight1 * glTFmorphPosition1\n        //     ...\n        // then we need to convert from relative to absolute here.\n        if (target.POSITION !== undefined) {\n          // Cloning not to pollute original accessor\n          var positionAttribute = cloneBufferAttribute(accessors[target.POSITION]);\n          positionAttribute.name = attributeName;\n          var position = geometry.attributes.position;\n\n          for (var j = 0, jl = positionAttribute.count; j < jl; j++) {\n            positionAttribute.setXYZ(j, positionAttribute.getX(j) + position.getX(j), positionAttribute.getY(j) + position.getY(j), positionAttribute.getZ(j) + position.getZ(j));\n          }\n        } else {\n          positionAttribute = geometry.attributes.position;\n        }\n\n        morphPositions.push(positionAttribute);\n      }\n\n      if (hasMorphNormal) {\n        // see target.POSITION's comment\n        var normalAttribute;\n\n        if (target.NORMAL !== undefined) {\n          normalAttribute = cloneBufferAttribute(accessors[target.NORMAL]);\n          normalAttribute.name = attributeName;\n          var normal = geometry.attributes.normal;\n\n          for (var _j = 0, _jl = normalAttribute.count; _j < _jl; _j++) {\n            normalAttribute.setXYZ(_j, normalAttribute.getX(_j) + normal.getX(_j), normalAttribute.getY(_j) + normal.getY(_j), normalAttribute.getZ(_j) + normal.getZ(_j));\n          }\n        } else {\n          normalAttribute = geometry.attributes.normal;\n        }\n\n        morphNormals.push(normalAttribute);\n      }\n    }\n\n    if (hasMorphPosition) geometry.morphAttributes.position = morphPositions;\n    if (hasMorphNormal) geometry.morphAttributes.normal = morphNormals;\n    mesh.updateMorphTargets();\n\n    if (meshDef.weights !== undefined) {\n      for (var i = 0, il = meshDef.weights.length; i < il; i++) {\n        mesh.morphTargetInfluences[i] = meshDef.weights[i];\n      }\n    } // .extras has user-defined data, so check that .extras.targetNames is an array.\n\n\n    if (meshDef.extras && Array.isArray(meshDef.extras.targetNames)) {\n      var targetNames = meshDef.extras.targetNames;\n\n      if (mesh.morphTargetInfluences.length === targetNames.length) {\n        mesh.morphTargetDictionary = {};\n\n        for (var _i3 = 0, _il3 = targetNames.length; _i3 < _il3; _i3++) {\n          mesh.morphTargetDictionary[targetNames[_i3]] = _i3;\n        }\n      } else {\n        console.warn('THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.');\n      }\n    }\n  }\n\n  function isPrimitiveEqual(a, b) {\n    if (a.indices !== b.indices) {\n      return false;\n    }\n\n    var attribA = a.attributes || {};\n    var attribB = b.attributes || {};\n    var keysA = Object.keys(attribA);\n    var keysB = Object.keys(attribB);\n\n    if (keysA.length !== keysB.length) {\n      return false;\n    }\n\n    for (var i = 0, il = keysA.length; i < il; i++) {\n      var key = keysA[i];\n\n      if (attribA[key] !== attribB[key]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  function getCachedGeometry(cache, newPrimitive) {\n    for (var i = 0, il = cache.length; i < il; i++) {\n      var cached = cache[i];\n\n      if (isPrimitiveEqual(cached.primitive, newPrimitive)) {\n        return cached.promise;\n      }\n    }\n\n    return null;\n  }\n\n  function cloneBufferAttribute(attribute) {\n    if (attribute.isInterleavedBufferAttribute) {\n      var count = attribute.count;\n      var itemSize = attribute.itemSize;\n      var array = attribute.array.slice(0, count * itemSize);\n\n      for (var i = 0; i < count; ++i) {\n        array[i] = attribute.getX(i);\n        if (itemSize >= 2) array[i + 1] = attribute.getY(i);\n        if (itemSize >= 3) array[i + 2] = attribute.getZ(i);\n        if (itemSize >= 4) array[i + 3] = attribute.getW(i);\n      }\n\n      return new THREE.BufferAttribute(array, itemSize, attribute.normalized);\n    }\n\n    return attribute.clone();\n  }\n  /* GLTF PARSER */\n\n\n  function GLTFParser(json, extensions, options) {\n    this.json = json || {};\n    this.extensions = extensions || {};\n    this.options = options || {}; // loader object cache\n\n    this.cache = new GLTFRegistry(); // BufferGeometry caching\n\n    this.primitiveCache = [];\n    this.textureLoader = new THREE.TextureLoader(this.options.manager);\n    this.textureLoader.setCrossOrigin(this.options.crossOrigin);\n    this.fileLoader = new THREE.FileLoader(this.options.manager);\n    this.fileLoader.setResponseType('arraybuffer');\n  }\n\n  GLTFParser.prototype.parse = function (onLoad, onError) {\n    var json = this.json; // Clear the loader cache\n\n    this.cache.removeAll(); // Mark the special nodes/meshes in json for efficient parse\n\n    this.markDefs(); // Fire the callback on complete\n\n    this.getMultiDependencies(['scene', 'animation', 'camera']).then(function (dependencies) {\n      var scenes = dependencies.scenes || [];\n      var scene = scenes[json.scene || 0];\n      var animations = dependencies.animations || [];\n      var asset = json.asset;\n      var cameras = dependencies.cameras || [];\n      onLoad(scene, scenes, cameras, animations, asset);\n    }).catch(onError);\n  };\n  /**\n   * Marks the special nodes/meshes in json for efficient parse.\n   */\n\n\n  GLTFParser.prototype.markDefs = function () {\n    var nodeDefs = this.json.nodes || [];\n    var skinDefs = this.json.skins || [];\n    var meshDefs = this.json.meshes || [];\n    var meshReferences = {};\n    var meshUses = {}; // Nothing in the node definition indicates whether it is a Bone or an\n    // Object3D. Use the skins' joint references to mark bones.\n\n    for (var skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex++) {\n      var joints = skinDefs[skinIndex].joints;\n\n      for (var i = 0, il = joints.length; i < il; i++) {\n        nodeDefs[joints[i]].isBone = true;\n      }\n    } // Meshes can (and should) be reused by multiple nodes in a glTF asset. To\n    // avoid having more than one THREE.Mesh with the same name, count\n    // references and rename instances below.\n    //\n    // Example: CesiumMilkTruck sample model reuses \"Wheel\" meshes.\n\n\n    for (var nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {\n      var nodeDef = nodeDefs[nodeIndex];\n\n      if (nodeDef.mesh !== undefined) {\n        if (meshReferences[nodeDef.mesh] === undefined) {\n          meshReferences[nodeDef.mesh] = meshUses[nodeDef.mesh] = 0;\n        }\n\n        meshReferences[nodeDef.mesh]++; // Nothing in the mesh definition indicates whether it is\n        // a SkinnedMesh or Mesh. Use the node's mesh reference\n        // to mark SkinnedMesh if node has skin.\n\n        if (nodeDef.skin !== undefined) {\n          meshDefs[nodeDef.mesh].isSkinnedMesh = true;\n        }\n      }\n    }\n\n    this.json.meshReferences = meshReferences;\n    this.json.meshUses = meshUses;\n  };\n  /**\n   * Requests the specified dependency asynchronously, with caching.\n   * @param {string} type\n   * @param {number} index\n   * @return {Promise<Object>}\n   */\n\n\n  GLTFParser.prototype.getDependency = function (type, index) {\n    var cacheKey = type + ':' + index;\n    var dependency = this.cache.get(cacheKey);\n\n    if (!dependency) {\n      switch (type) {\n        case 'scene':\n          dependency = this.loadScene(index);\n          break;\n\n        case 'node':\n          dependency = this.loadNode(index);\n          break;\n\n        case 'mesh':\n          dependency = this.loadMesh(index);\n          break;\n\n        case 'accessor':\n          dependency = this.loadAccessor(index);\n          break;\n\n        case 'bufferView':\n          dependency = this.loadBufferView(index);\n          break;\n\n        case 'buffer':\n          dependency = this.loadBuffer(index);\n          break;\n\n        case 'material':\n          dependency = this.loadMaterial(index);\n          break;\n\n        case 'texture':\n          dependency = this.loadTexture(index);\n          break;\n\n        case 'skin':\n          dependency = this.loadSkin(index);\n          break;\n\n        case 'animation':\n          dependency = this.loadAnimation(index);\n          break;\n\n        case 'camera':\n          dependency = this.loadCamera(index);\n          break;\n\n        default:\n          throw new Error('Unknown type: ' + type);\n      }\n\n      this.cache.add(cacheKey, dependency);\n    }\n\n    return dependency;\n  };\n  /**\n   * Requests all dependencies of the specified type asynchronously, with caching.\n   * @param {string} type\n   * @return {Promise<Array<Object>>}\n   */\n\n\n  GLTFParser.prototype.getDependencies = function (type) {\n    var dependencies = this.cache.get(type);\n\n    if (!dependencies) {\n      var parser = this;\n      var defs = this.json[type + (type === 'mesh' ? 'es' : 's')] || [];\n      dependencies = Promise.all(defs.map(function (def, index) {\n        return parser.getDependency(type, index);\n      }));\n      this.cache.add(type, dependencies);\n    }\n\n    return dependencies;\n  };\n  /**\n   * Requests all multiple dependencies of the specified types asynchronously, with caching.\n   * @param {Array<string>} types\n   * @return {Promise<Object<Array<Object>>>}\n   */\n\n\n  GLTFParser.prototype.getMultiDependencies = function (types) {\n    var results = {};\n    var pendings = [];\n\n    for (var i = 0, il = types.length; i < il; i++) {\n      var type = types[i];\n      var value = this.getDependencies(type);\n      value = value.then(function (key, value) {\n        results[key] = value;\n      }.bind(this, type + (type === 'mesh' ? 'es' : 's')));\n      pendings.push(value);\n    }\n\n    return Promise.all(pendings).then(function () {\n      return results;\n    });\n  };\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n   * @param {number} bufferIndex\n   * @return {Promise<ArrayBuffer>}\n   */\n\n\n  GLTFParser.prototype.loadBuffer = function (bufferIndex) {\n    var bufferDef = this.json.buffers[bufferIndex];\n    var loader = this.fileLoader;\n\n    if (bufferDef.type && bufferDef.type !== 'arraybuffer') {\n      throw new Error('THREE.GLTFLoader: ' + bufferDef.type + ' buffer type is not supported.');\n    } // If present, GLB container is required to be the first buffer.\n\n\n    if (bufferDef.uri === undefined && bufferIndex === 0) {\n      return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body);\n    }\n\n    var options = this.options;\n    return new Promise(function (resolve, reject) {\n      loader.load(resolveURL(bufferDef.uri, options.path), resolve, undefined, function () {\n        reject(new Error('THREE.GLTFLoader: Failed to load buffer \"' + bufferDef.uri + '\".'));\n      });\n    });\n  };\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n   * @param {number} bufferViewIndex\n   * @return {Promise<ArrayBuffer>}\n   */\n\n\n  GLTFParser.prototype.loadBufferView = function (bufferViewIndex) {\n    var bufferViewDef = this.json.bufferViews[bufferViewIndex];\n    return this.getDependency('buffer', bufferViewDef.buffer).then(function (buffer) {\n      var byteLength = bufferViewDef.byteLength || 0;\n      var byteOffset = bufferViewDef.byteOffset || 0;\n      return buffer.slice(byteOffset, byteOffset + byteLength);\n    });\n  };\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors\n   * @param {number} accessorIndex\n   * @return {Promise<THREE.BufferAttribute|THREE.InterleavedBufferAttribute>}\n   */\n\n\n  GLTFParser.prototype.loadAccessor = function (accessorIndex) {\n    var parser = this;\n    var json = this.json;\n    var accessorDef = this.json.accessors[accessorIndex];\n\n    if (accessorDef.bufferView === undefined && accessorDef.sparse === undefined) {\n      // Ignore empty accessors, which may be used to declare runtime\n      // information about attributes coming from another source (e.g. Draco\n      // compression extension).\n      return null;\n    }\n\n    var pendingBufferViews = [];\n\n    if (accessorDef.bufferView !== undefined) {\n      pendingBufferViews.push(this.getDependency('bufferView', accessorDef.bufferView));\n    } else {\n      pendingBufferViews.push(null);\n    }\n\n    if (accessorDef.sparse !== undefined) {\n      pendingBufferViews.push(this.getDependency('bufferView', accessorDef.sparse.indices.bufferView));\n      pendingBufferViews.push(this.getDependency('bufferView', accessorDef.sparse.values.bufferView));\n    }\n\n    return Promise.all(pendingBufferViews).then(function (bufferViews) {\n      var bufferView = bufferViews[0];\n      var itemSize = WEBGL_TYPE_SIZES[accessorDef.type];\n      var TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType]; // For VEC3: itemSize is 3, elementBytes is 4, itemBytes is 12.\n\n      var elementBytes = TypedArray.BYTES_PER_ELEMENT;\n      var itemBytes = elementBytes * itemSize;\n      var byteOffset = accessorDef.byteOffset || 0;\n      var byteStride = json.bufferViews[accessorDef.bufferView].byteStride;\n      var normalized = accessorDef.normalized === true;\n      var array, bufferAttribute; // The buffer is not interleaved if the stride is the item size in bytes.\n\n      if (byteStride && byteStride !== itemBytes) {\n        var ibCacheKey = 'InterleavedBuffer:' + accessorDef.bufferView + ':' + accessorDef.componentType;\n        var ib = parser.cache.get(ibCacheKey);\n\n        if (!ib) {\n          // Use the full buffer if it's interleaved.\n          array = new TypedArray(bufferView); // Integer parameters to IB/IBA are in array elements, not bytes.\n\n          ib = new THREE.InterleavedBuffer(array, byteStride / elementBytes);\n          parser.cache.add(ibCacheKey, ib);\n        }\n\n        bufferAttribute = new THREE.InterleavedBufferAttribute(ib, itemSize, byteOffset / elementBytes, normalized);\n      } else {\n        if (bufferView === null) {\n          array = new TypedArray(accessorDef.count * itemSize);\n        } else {\n          array = new TypedArray(bufferView, byteOffset, accessorDef.count * itemSize);\n        }\n\n        bufferAttribute = new THREE.BufferAttribute(array, itemSize, normalized);\n      } // https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#sparse-accessors\n\n\n      if (accessorDef.sparse !== undefined) {\n        var itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;\n        var TypedArrayIndices = WEBGL_COMPONENT_TYPES[accessorDef.sparse.indices.componentType];\n        var byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;\n        var byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;\n        var sparseIndices = new TypedArrayIndices(bufferViews[1], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices);\n        var sparseValues = new TypedArray(bufferViews[2], byteOffsetValues, accessorDef.sparse.count * itemSize);\n\n        if (bufferView !== null) {\n          // Avoid modifying the original ArrayBuffer, if the bufferView wasn't initialized with zeroes.\n          bufferAttribute.setArray(bufferAttribute.array.slice());\n        }\n\n        for (var i = 0, il = sparseIndices.length; i < il; i++) {\n          var index = sparseIndices[i];\n          bufferAttribute.setX(index, sparseValues[i * itemSize]);\n          if (itemSize >= 2) bufferAttribute.setY(index, sparseValues[i * itemSize + 1]);\n          if (itemSize >= 3) bufferAttribute.setZ(index, sparseValues[i * itemSize + 2]);\n          if (itemSize >= 4) bufferAttribute.setW(index, sparseValues[i * itemSize + 3]);\n          if (itemSize >= 5) throw new Error('THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.');\n        }\n      }\n\n      return bufferAttribute;\n    });\n  };\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures\n   * @param {number} textureIndex\n   * @return {Promise<THREE.Texture>}\n   */\n\n\n  GLTFParser.prototype.loadTexture = function (textureIndex) {\n    var parser = this;\n    var json = this.json;\n    var options = this.options;\n    var textureLoader = this.textureLoader;\n    var URL = window.URL || window.webkitURL;\n    var textureDef = json.textures[textureIndex];\n    var textureExtensions = textureDef.extensions || {};\n    var source;\n\n    if (textureExtensions[EXTENSIONS.MSFT_TEXTURE_DDS]) {\n      source = json.images[textureExtensions[EXTENSIONS.MSFT_TEXTURE_DDS].source];\n    } else {\n      source = json.images[textureDef.source];\n    }\n\n    var sourceURI = source.uri;\n    var isObjectURL = false;\n\n    if (source.bufferView !== undefined) {\n      // Load binary image data from bufferView, if provided.\n      sourceURI = parser.getDependency('bufferView', source.bufferView).then(function (bufferView) {\n        isObjectURL = true;\n        var blob = new Blob([bufferView], {\n          type: source.mimeType\n        });\n        sourceURI = URL.createObjectURL(blob);\n        return sourceURI;\n      });\n    }\n\n    return Promise.resolve(sourceURI).then(function (sourceURI) {\n      // Load Texture resource.\n      var loader = THREE.Loader.Handlers.get(sourceURI);\n\n      if (!loader) {\n        loader = textureExtensions[EXTENSIONS.MSFT_TEXTURE_DDS] ? parser.extensions[EXTENSIONS.MSFT_TEXTURE_DDS].ddsLoader : textureLoader;\n      }\n\n      return new Promise(function (resolve, reject) {\n        loader.load(resolveURL(sourceURI, options.path), resolve, undefined, reject);\n      });\n    }).then(function (texture) {\n      // Clean up resources and configure Texture.\n      if (isObjectURL === true) {\n        URL.revokeObjectURL(sourceURI);\n      }\n\n      texture.flipY = false;\n      if (textureDef.name !== undefined) texture.name = textureDef.name; // .format of dds texture is set in DDSLoader\n\n      if (!textureExtensions[EXTENSIONS.MSFT_TEXTURE_DDS]) {\n        texture.format = textureDef.format !== undefined ? WEBGL_TEXTURE_FORMATS[textureDef.format] : THREE.RGBAFormat;\n      }\n\n      if (textureDef.internalFormat !== undefined && texture.format !== WEBGL_TEXTURE_FORMATS[textureDef.internalFormat]) {\n        console.warn('THREE.GLTFLoader: Three.js does not support texture internalFormat which is different from texture format. ' + 'internalFormat will be forced to be the same value as format.');\n      }\n\n      texture.type = textureDef.type !== undefined ? WEBGL_TEXTURE_DATATYPES[textureDef.type] : THREE.UnsignedByteType;\n      var samplers = json.samplers || {};\n      var sampler = samplers[textureDef.sampler] || {};\n      texture.magFilter = WEBGL_FILTERS[sampler.magFilter] || THREE.LinearFilter;\n      texture.minFilter = WEBGL_FILTERS[sampler.minFilter] || THREE.LinearMipMapLinearFilter;\n      texture.wrapS = WEBGL_WRAPPINGS[sampler.wrapS] || THREE.RepeatWrapping;\n      texture.wrapT = WEBGL_WRAPPINGS[sampler.wrapT] || THREE.RepeatWrapping;\n      return texture;\n    });\n  };\n  /**\n   * Asynchronously assigns a texture to the given material parameters.\n   * @param {Object} materialParams\n   * @param {string} textureName\n   * @param {number} textureIndex\n   * @return {Promise}\n   */\n\n\n  GLTFParser.prototype.assignTexture = function (materialParams, textureName, textureIndex) {\n    return this.getDependency('texture', textureIndex).then(function (texture) {\n      materialParams[textureName] = texture;\n    });\n  };\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials\n   * @param {number} materialIndex\n   * @return {Promise<THREE.Material>}\n   */\n\n\n  GLTFParser.prototype.loadMaterial = function (materialIndex) {\n    var parser = this;\n    var extensions = this.extensions;\n    var materialDef = this.json.materials[materialIndex];\n    var materialType;\n    var materialParams = {};\n    var materialExtensions = materialDef.extensions || {};\n    var pending = [];\n\n    if (materialExtensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {\n      var sgExtension = extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];\n      materialType = sgExtension.getMaterialType(materialDef);\n      pending.push(sgExtension.extendParams(materialParams, materialDef, parser));\n    } else if (materialExtensions[EXTENSIONS.KHR_MATERIALS_UNLIT]) {\n      var kmuExtension = extensions[EXTENSIONS.KHR_MATERIALS_UNLIT];\n      materialType = kmuExtension.getMaterialType(materialDef);\n      pending.push(kmuExtension.extendParams(materialParams, materialDef, parser));\n    } else {\n      // Specification:\n      // https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#metallic-roughness-material\n      materialType = THREE.MeshStandardMaterial;\n      var metallicRoughness = materialDef.pbrMetallicRoughness || {};\n      materialParams.color = new THREE.Color(1.0, 1.0, 1.0);\n      materialParams.opacity = 1.0;\n\n      if (Array.isArray(metallicRoughness.baseColorFactor)) {\n        var array = metallicRoughness.baseColorFactor;\n        materialParams.color.fromArray(array);\n        materialParams.opacity = array[3];\n      }\n\n      if (metallicRoughness.baseColorTexture !== undefined) {\n        pending.push(parser.assignTexture(materialParams, 'map', metallicRoughness.baseColorTexture.index));\n      }\n\n      materialParams.metalness = metallicRoughness.metallicFactor !== undefined ? metallicRoughness.metallicFactor : 1.0;\n      materialParams.roughness = metallicRoughness.roughnessFactor !== undefined ? metallicRoughness.roughnessFactor : 1.0;\n\n      if (metallicRoughness.metallicRoughnessTexture !== undefined) {\n        var textureIndex = metallicRoughness.metallicRoughnessTexture.index;\n        pending.push(parser.assignTexture(materialParams, 'metalnessMap', textureIndex));\n        pending.push(parser.assignTexture(materialParams, 'roughnessMap', textureIndex));\n      }\n    }\n\n    if (materialDef.doubleSided === true) {\n      materialParams.side = THREE.DoubleSide;\n    }\n\n    var alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;\n\n    if (alphaMode === ALPHA_MODES.BLEND) {\n      materialParams.transparent = true;\n    } else {\n      materialParams.transparent = false;\n\n      if (alphaMode === ALPHA_MODES.MASK) {\n        materialParams.alphaTest = materialDef.alphaCutoff !== undefined ? materialDef.alphaCutoff : 0.5;\n      }\n    }\n\n    if (materialDef.normalTexture !== undefined && materialType !== THREE.MeshBasicMaterial) {\n      pending.push(parser.assignTexture(materialParams, 'normalMap', materialDef.normalTexture.index));\n      materialParams.normalScale = new THREE.Vector2(1, 1);\n\n      if (materialDef.normalTexture.scale !== undefined) {\n        materialParams.normalScale.set(materialDef.normalTexture.scale, materialDef.normalTexture.scale);\n      }\n    }\n\n    if (materialDef.occlusionTexture !== undefined && materialType !== THREE.MeshBasicMaterial) {\n      pending.push(parser.assignTexture(materialParams, 'aoMap', materialDef.occlusionTexture.index));\n\n      if (materialDef.occlusionTexture.strength !== undefined) {\n        materialParams.aoMapIntensity = materialDef.occlusionTexture.strength;\n      }\n    }\n\n    if (materialDef.emissiveFactor !== undefined && materialType !== THREE.MeshBasicMaterial) {\n      materialParams.emissive = new THREE.Color().fromArray(materialDef.emissiveFactor);\n    }\n\n    if (materialDef.emissiveTexture !== undefined && materialType !== THREE.MeshBasicMaterial) {\n      pending.push(parser.assignTexture(materialParams, 'emissiveMap', materialDef.emissiveTexture.index));\n    }\n\n    return Promise.all(pending).then(function () {\n      var material;\n\n      if (materialType === THREE.ShaderMaterial) {\n        material = extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(materialParams);\n      } else {\n        material = new materialType(materialParams);\n      }\n\n      if (materialDef.name !== undefined) material.name = materialDef.name; // Normal map textures use OpenGL conventions:\n      // https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#materialnormaltexture\n\n      if (material.normalScale) {\n        material.normalScale.y = -material.normalScale.y;\n      } // emissiveTexture and baseColorTexture use sRGB encoding.\n\n\n      if (material.map) material.map.encoding = THREE.sRGBEncoding;\n      if (material.emissiveMap) material.emissiveMap.encoding = THREE.sRGBEncoding;\n      if (materialDef.extras) material.userData = materialDef.extras;\n      return material;\n    });\n  };\n  /**\n   * @param  {THREE.BufferGeometry} geometry\n   * @param  {GLTF.Primitive} primitiveDef\n   * @param  {Array<THREE.BufferAttribute>} accessors\n   */\n\n\n  function addPrimitiveAttributes(geometry, primitiveDef, accessors) {\n    var attributes = primitiveDef.attributes;\n\n    for (var gltfAttributeName in attributes) {\n      var threeAttributeName = ATTRIBUTES[gltfAttributeName];\n      var bufferAttribute = accessors[attributes[gltfAttributeName]]; // Skip attributes already provided by e.g. Draco extension.\n\n      if (!threeAttributeName) continue;\n      if (threeAttributeName in geometry.attributes) continue;\n      geometry.addAttribute(threeAttributeName, bufferAttribute);\n    }\n\n    if (primitiveDef.indices !== undefined && !geometry.index) {\n      geometry.setIndex(accessors[primitiveDef.indices]);\n    }\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry\n   * @param {Array<Object>} primitives\n   * @return {Promise<Array<THREE.BufferGeometry>>}\n   */\n\n\n  GLTFParser.prototype.loadGeometries = function (primitives) {\n    var parser = this;\n    var extensions = this.extensions;\n    var cache = this.primitiveCache;\n    return this.getDependencies('accessor').then(function (accessors) {\n      function addPrimitives(geometry) {\n        addPrimitiveAttributes(geometry, primitive, accessors);\n        return geometry;\n      }\n\n      ;\n      var pending = [];\n      var geometryPromise = null;\n\n      for (var i = 0, il = primitives.length; i < il; i++) {\n        var primitive = primitives[i]; // See if we've already created this geometry\n\n        var cached = getCachedGeometry(cache, primitive);\n\n        if (cached) {\n          // Use the cached geometry if it exists\n          pending.push(cached);\n        } else if (primitive.extensions && primitive.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]) {\n          // Use DRACO geometry if available\n          geometryPromise = extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(primitive, parser).then(addPrimitives);\n          cache.push({\n            primitive: primitive,\n            promise: geometryPromise\n          });\n          pending.push(geometryPromise);\n        } else {\n          // Otherwise create a new geometry\n          var geometry = new THREE.BufferGeometry();\n          addPrimitiveAttributes(geometry, primitive, accessors);\n          geometryPromise = Promise.resolve(geometry); // Cache this geometry\n\n          cache.push({\n            primitive: primitive,\n            promise: geometryPromise\n          });\n          pending.push(geometryPromise);\n        }\n      }\n\n      return Promise.all(pending);\n    });\n  };\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes\n   * @param {number} meshIndex\n   * @return {Promise<THREE.Group|THREE.Mesh|THREE.SkinnedMesh>}\n   */\n\n\n  GLTFParser.prototype.loadMesh = function (meshIndex) {\n    var scope = this;\n    var extensions = this.extensions;\n    var meshDef = this.json.meshes[meshIndex];\n    return this.getMultiDependencies(['accessor', 'material']).then(function (dependencies) {\n      var group = new THREE.Group();\n      var primitives = meshDef.primitives;\n      return scope.loadGeometries(primitives).then(function (geometries) {\n        for (var i = 0, il = primitives.length; i < il; i++) {\n          var primitive = primitives[i];\n          var geometry = geometries[i];\n          var material = primitive.material === undefined ? createDefaultMaterial() : dependencies.materials[primitive.material];\n\n          if (material.aoMap && geometry.attributes.uv2 === undefined && geometry.attributes.uv !== undefined) {\n            console.log('THREE.GLTFLoader: Duplicating UVs to support aoMap.');\n            geometry.addAttribute('uv2', new THREE.BufferAttribute(geometry.attributes.uv.array, 2));\n          } // If the material will be modified later on, clone it now.\n\n\n          var useVertexColors = geometry.attributes.color !== undefined;\n          var useFlatShading = geometry.attributes.normal === undefined;\n          var useSkinning = meshDef.isSkinnedMesh === true;\n          var useMorphTargets = primitive.targets !== undefined;\n\n          if (useVertexColors || useFlatShading || useSkinning || useMorphTargets) {\n            if (material.isGLTFSpecularGlossinessMaterial) {\n              var specGlossExtension = extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];\n              material = specGlossExtension.cloneMaterial(material);\n            } else {\n              material = material.clone();\n            }\n          }\n\n          if (useVertexColors) {\n            material.vertexColors = THREE.VertexColors;\n            material.needsUpdate = true;\n          }\n\n          if (useFlatShading) {\n            material.flatShading = true;\n          }\n\n          var mesh;\n          var cacheKey;\n\n          if (primitive.mode === WEBGL_CONSTANTS.TRIANGLES || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN || primitive.mode === undefined) {\n            if (useSkinning) {\n              mesh = new THREE.SkinnedMesh(geometry, material);\n              material.skinning = true;\n            } else {\n              mesh = new THREE.Mesh(geometry, material);\n            }\n\n            if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP) {\n              mesh.drawMode = THREE.TriangleStripDrawMode;\n            } else if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN) {\n              mesh.drawMode = THREE.TriangleFanDrawMode;\n            }\n          } else if (primitive.mode === WEBGL_CONSTANTS.LINES || primitive.mode === WEBGL_CONSTANTS.LINE_STRIP || primitive.mode === WEBGL_CONSTANTS.LINE_LOOP) {\n            cacheKey = 'LineBasicMaterial:' + material.uuid;\n            var lineMaterial = scope.cache.get(cacheKey);\n\n            if (!lineMaterial) {\n              lineMaterial = new THREE.LineBasicMaterial();\n              THREE.Material.prototype.copy.call(lineMaterial, material);\n              lineMaterial.color.copy(material.color);\n              lineMaterial.lights = false; // LineBasicMaterial doesn't support lights yet\n\n              scope.cache.add(cacheKey, lineMaterial);\n            }\n\n            material = lineMaterial;\n\n            if (primitive.mode === WEBGL_CONSTANTS.LINES) {\n              mesh = new THREE.LineSegments(geometry, material);\n            } else if (primitive.mode === WEBGL_CONSTANTS.LINE_STRIP) {\n              mesh = new THREE.Line(geometry, material);\n            } else {\n              mesh = new THREE.LineLoop(geometry, material);\n            }\n          } else if (primitive.mode === WEBGL_CONSTANTS.POINTS) {\n            cacheKey = 'PointsMaterial:' + material.uuid;\n            var pointsMaterial = scope.cache.get(cacheKey);\n\n            if (!pointsMaterial) {\n              pointsMaterial = new THREE.PointsMaterial();\n              THREE.Material.prototype.copy.call(pointsMaterial, material);\n              pointsMaterial.color.copy(material.color);\n              pointsMaterial.map = material.map;\n              pointsMaterial.lights = false; // PointsMaterial doesn't support lights yet\n\n              scope.cache.add(cacheKey, pointsMaterial);\n            }\n\n            material = pointsMaterial;\n            mesh = new THREE.Points(geometry, material);\n          } else {\n            throw new Error('THREE.GLTFLoader: Primitive mode unsupported: ' + primitive.mode);\n          }\n\n          mesh.name = meshDef.name || 'mesh_' + meshIndex;\n\n          if (useMorphTargets) {\n            addMorphTargets(mesh, meshDef, primitive, dependencies.accessors);\n            material.morphTargets = true;\n            if (mesh.geometry.morphAttributes.normal !== undefined) material.morphNormals = true;\n          }\n\n          if (meshDef.extras !== undefined) mesh.userData = meshDef.extras;\n          if (primitive.extras !== undefined) mesh.geometry.userData = primitive.extras; // for Specular-Glossiness.\n\n          if (material.isGLTFSpecularGlossinessMaterial === true) {\n            mesh.onBeforeRender = extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].refreshUniforms;\n          }\n\n          if (primitives.length > 1) {\n            mesh.name += '_' + i;\n            group.add(mesh);\n          } else {\n            return mesh;\n          }\n        }\n\n        return group;\n      });\n    });\n  };\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras\n   * @param {number} cameraIndex\n   * @return {Promise<THREE.Camera>}\n   */\n\n\n  GLTFParser.prototype.loadCamera = function (cameraIndex) {\n    var camera;\n    var cameraDef = this.json.cameras[cameraIndex];\n    var params = cameraDef[cameraDef.type];\n\n    if (!params) {\n      console.warn('THREE.GLTFLoader: Missing camera parameters.');\n      return;\n    }\n\n    if (cameraDef.type === 'perspective') {\n      camera = new THREE.PerspectiveCamera(THREE.Math.radToDeg(params.yfov), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6);\n    } else if (cameraDef.type === 'orthographic') {\n      camera = new THREE.OrthographicCamera(params.xmag / -2, params.xmag / 2, params.ymag / 2, params.ymag / -2, params.znear, params.zfar);\n    }\n\n    if (cameraDef.name !== undefined) camera.name = cameraDef.name;\n    if (cameraDef.extras) camera.userData = cameraDef.extras;\n    return Promise.resolve(camera);\n  };\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins\n   * @param {number} skinIndex\n   * @return {Promise<Object>}\n   */\n\n\n  GLTFParser.prototype.loadSkin = function (skinIndex) {\n    var skinDef = this.json.skins[skinIndex];\n    var skinEntry = {\n      joints: skinDef.joints\n    };\n\n    if (skinDef.inverseBindMatrices === undefined) {\n      return Promise.resolve(skinEntry);\n    }\n\n    return this.getDependency('accessor', skinDef.inverseBindMatrices).then(function (accessor) {\n      skinEntry.inverseBindMatrices = accessor;\n      return skinEntry;\n    });\n  };\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations\n   * @param {number} animationIndex\n   * @return {Promise<THREE.AnimationClip>}\n   */\n\n\n  GLTFParser.prototype.loadAnimation = function (animationIndex) {\n    var animationDef = this.json.animations[animationIndex];\n    return this.getMultiDependencies(['accessor', 'node']).then(function (dependencies) {\n      var tracks = [];\n\n      function pushToTargetNames(object) {\n        if (object.isMesh === true && object.material.morphTargets === true) {\n          targetNames.push(object.name ? object.name : object.uuid);\n        }\n      }\n\n      for (var i = 0, il = animationDef.channels.length; i < il; i++) {\n        var channel = animationDef.channels[i];\n        var sampler = animationDef.samplers[channel.sampler];\n        var name;\n\n        if (sampler) {\n          var target = channel.target;\n          name = target.node !== undefined ? target.node : target.id; // NOTE: target.id is deprecated.\n\n          var input = animationDef.parameters !== undefined ? animationDef.parameters[sampler.input] : sampler.input;\n          var output = animationDef.parameters !== undefined ? animationDef.parameters[sampler.output] : sampler.output;\n          var inputAccessor = dependencies.accessors[input];\n          var outputAccessor = dependencies.accessors[output];\n          var node = dependencies.nodes[name];\n\n          if (node) {\n            node.updateMatrix();\n            node.matrixAutoUpdate = true;\n            var TypedKeyframeTrack;\n\n            switch (PATH_PROPERTIES[target.path]) {\n              case PATH_PROPERTIES.weights:\n                TypedKeyframeTrack = THREE.NumberKeyframeTrack;\n                break;\n\n              case PATH_PROPERTIES.rotation:\n                TypedKeyframeTrack = THREE.QuaternionKeyframeTrack;\n                break;\n\n              case PATH_PROPERTIES.position:\n              case PATH_PROPERTIES.scale:\n              default:\n                TypedKeyframeTrack = THREE.VectorKeyframeTrack;\n                break;\n            }\n\n            var targetName = node.name ? node.name : node.uuid;\n            var interpolation = sampler.interpolation !== undefined ? INTERPOLATION[sampler.interpolation] : THREE.InterpolateLinear;\n            var targetNames = [];\n\n            if (PATH_PROPERTIES[target.path] === PATH_PROPERTIES.weights) {\n              // node should be THREE.Group here but\n              // PATH_PROPERTIES.weights(morphTargetInfluences) should be\n              // the property of a mesh object under node.\n              // So finding targets here.\n              node.traverse(pushToTargetNames);\n            } else {\n              targetNames.push(targetName);\n            } // KeyframeTrack.optimize() will modify given 'times' and 'values'\n            // buffers before creating a truncated copy to keep. Because buffers may\n            // be reused by other tracks, make copies here.\n\n\n            for (var j = 0, jl = targetNames.length; j < jl; j++) {\n              var track = new TypedKeyframeTrack(targetNames[j] + '.' + PATH_PROPERTIES[target.path], THREE.AnimationUtils.arraySlice(inputAccessor.array, 0), THREE.AnimationUtils.arraySlice(outputAccessor.array, 0), interpolation); // Here is the trick to enable custom interpolation.\n              // Overrides .createInterpolant in a factory method which creates custom interpolation.\n\n              if (sampler.interpolation === 'CUBICSPLINE') {\n                track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline(result) {\n                  // A CUBICSPLINE keyframe in glTF has three output values for each input value,\n                  // representing inTangent, splineVertex, and outTangent. As a result, track.getValueSize()\n                  // must be divided by three to get the interpolant's sampleSize argument.\n                  return new GLTFCubicSplineInterpolant(this.times, this.values, this.getValueSize() / 3, result);\n                }; // Workaround, provide an alternate way to know if the interpolant type is cubis spline to track.\n                // track.getInterpolation() doesn't return valid value for custom interpolant.\n\n\n                track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;\n              }\n\n              tracks.push(track);\n            }\n          }\n        }\n      }\n\n      name = animationDef.name !== undefined ? animationDef.name : 'animation_' + animationIndex;\n      return new THREE.AnimationClip(name, undefined, tracks);\n    });\n  };\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy\n   * @param {number} nodeIndex\n   * @return {Promise<THREE.Object3D>}\n   */\n\n\n  GLTFParser.prototype.loadNode = function (nodeIndex) {\n    var extensions = this.extensions;\n    var meshReferences = this.json.meshReferences;\n    var meshUses = this.json.meshUses;\n    var nodeDef = this.json.nodes[nodeIndex];\n    return this.getMultiDependencies(['mesh', 'skin', 'camera', 'light']).then(function (dependencies) {\n      var node;\n\n      if (nodeDef.isBone === true) {\n        node = new THREE.Bone();\n      } else if (nodeDef.mesh !== undefined) {\n        var mesh = dependencies.meshes[nodeDef.mesh];\n        node = mesh.clone(); // for Specular-Glossiness\n\n        if (mesh.isGroup === true) {\n          for (var i = 0, il = mesh.children.length; i < il; i++) {\n            var child = mesh.children[i];\n\n            if (child.material && child.material.isGLTFSpecularGlossinessMaterial === true) {\n              node.children[i].onBeforeRender = child.onBeforeRender;\n            }\n          }\n        } else {\n          if (mesh.material && mesh.material.isGLTFSpecularGlossinessMaterial === true) {\n            node.onBeforeRender = mesh.onBeforeRender;\n          }\n        }\n\n        if (meshReferences[nodeDef.mesh] > 1) {\n          node.name += '_instance_' + meshUses[nodeDef.mesh]++;\n        }\n      } else if (nodeDef.camera !== undefined) {\n        node = dependencies.cameras[nodeDef.camera];\n      } else if (nodeDef.extensions && nodeDef.extensions[EXTENSIONS.KHR_LIGHTS] && nodeDef.extensions[EXTENSIONS.KHR_LIGHTS].light !== undefined) {\n        var lights = extensions[EXTENSIONS.KHR_LIGHTS].lights;\n        node = lights[nodeDef.extensions[EXTENSIONS.KHR_LIGHTS].light];\n      } else {\n        node = new THREE.Object3D();\n      }\n\n      if (nodeDef.name !== undefined) {\n        node.name = THREE.PropertyBinding.sanitizeNodeName(nodeDef.name);\n      }\n\n      if (nodeDef.extras) node.userData = nodeDef.extras;\n\n      if (nodeDef.matrix !== undefined) {\n        var matrix = new THREE.Matrix4();\n        matrix.fromArray(nodeDef.matrix);\n        node.applyMatrix(matrix);\n      } else {\n        if (nodeDef.translation !== undefined) {\n          node.position.fromArray(nodeDef.translation);\n        }\n\n        if (nodeDef.rotation !== undefined) {\n          node.quaternion.fromArray(nodeDef.rotation);\n        }\n\n        if (nodeDef.scale !== undefined) {\n          node.scale.fromArray(nodeDef.scale);\n        }\n      }\n\n      return node;\n    });\n  };\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes\n   * @param {number} sceneIndex\n   * @return {Promise<THREE.Scene>}\n   */\n\n\n  GLTFParser.prototype.loadScene = function () {\n    // scene node hierachy builder\n    function buildNodeHierachy(nodeId, parentObject, json, allNodes, skins) {\n      var node = allNodes[nodeId];\n      var nodeDef = json.nodes[nodeId]; // build skeleton here as well\n\n      if (nodeDef.skin !== undefined) {\n        var meshes = node.isGroup === true ? node.children : [node];\n\n        for (var i = 0, il = meshes.length; i < il; i++) {\n          var mesh = meshes[i];\n          var skinEntry = skins[nodeDef.skin];\n          var bones = [];\n          var boneInverses = [];\n\n          for (var j = 0, jl = skinEntry.joints.length; j < jl; j++) {\n            var jointId = skinEntry.joints[j];\n            var jointNode = allNodes[jointId];\n\n            if (jointNode) {\n              bones.push(jointNode);\n              var mat = new THREE.Matrix4();\n\n              if (skinEntry.inverseBindMatrices !== undefined) {\n                mat.fromArray(skinEntry.inverseBindMatrices.array, j * 16);\n              }\n\n              boneInverses.push(mat);\n            } else {\n              console.warn('THREE.GLTFLoader: Joint \"%s\" could not be found.', jointId);\n            }\n          }\n\n          mesh.bind(new THREE.Skeleton(bones, boneInverses), mesh.matrixWorld);\n        }\n      } // build node hierachy\n\n\n      parentObject.add(node);\n\n      if (nodeDef.children) {\n        var children = nodeDef.children;\n\n        for (var _i4 = 0, _il4 = children.length; _i4 < _il4; _i4++) {\n          var child = children[_i4];\n          buildNodeHierachy(child, node, json, allNodes, skins);\n        }\n      }\n    }\n\n    return function loadScene(sceneIndex) {\n      var json = this.json;\n      var extensions = this.extensions;\n      var sceneDef = this.json.scenes[sceneIndex];\n      return this.getMultiDependencies(['node', 'skin']).then(function (dependencies) {\n        var scene = new THREE.Scene();\n        if (sceneDef.name !== undefined) scene.name = sceneDef.name;\n        if (sceneDef.extras) scene.userData = sceneDef.extras;\n        var nodeIds = sceneDef.nodes || [];\n\n        for (var i = 0, il = nodeIds.length; i < il; i++) {\n          buildNodeHierachy(nodeIds[i], scene, json, dependencies.nodes, dependencies.skins);\n        } // Ambient lighting, if present, is always attached to the scene root.\n\n\n        if (sceneDef.extensions && sceneDef.extensions[EXTENSIONS.KHR_LIGHTS] && sceneDef.extensions[EXTENSIONS.KHR_LIGHTS].light !== undefined) {\n          var lights = extensions[EXTENSIONS.KHR_LIGHTS].lights;\n          scene.add(lights[sceneDef.extensions[EXTENSIONS.KHR_LIGHTS].light]);\n        }\n\n        return scene;\n      });\n    };\n  }();\n\n  return GLTFLoader;\n}();\n\nexport default GLTFLoader;","map":{"version":3,"sources":["/home/darlington-chuks/Documents/game-engine/src/game/utils/three/gltf-loader.js"],"names":["THREE","DDSLoader","GLTFLoader","manager","undefined","DefaultLoadingManager","dracoLoader","prototype","constructor","crossOrigin","load","url","onLoad","onProgress","onError","scope","path","LoaderUtils","extractUrlBase","loader","FileLoader","setResponseType","data","parse","e","setCrossOrigin","value","setPath","setDRACOLoader","content","extensions","magic","decodeText","Uint8Array","BINARY_EXTENSION_HEADER_MAGIC","EXTENSIONS","KHR_BINARY_GLTF","GLTFBinaryExtension","error","json","JSON","asset","version","Error","extensionsUsed","indexOf","KHR_LIGHTS","GLTFLightsExtension","KHR_MATERIALS_UNLIT","GLTFMaterialsUnlitExtension","KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS","GLTFMaterialsPbrSpecularGlossinessExtension","KHR_DRACO_MESH_COMPRESSION","GLTFDracoMeshCompressionExtension","MSFT_TEXTURE_DDS","GLTFTextureDDSExtension","parser","GLTFParser","scene","scenes","cameras","animations","glTF","GLTFRegistry","objects","get","key","add","object","remove","removeAll","name","ddsLoader","lights","extension","lightId","light","lightNode","color","Color","fromArray","type","DirectionalLight","target","position","set","PointLight","SpotLight","spot","innerConeAngle","outerConeAngle","Math","PI","angle","penumbra","AmbientLight","decay","intensity","getMaterialType","material","MeshBasicMaterial","extendParams","materialParams","pending","opacity","metallicRoughness","pbrMetallicRoughness","Array","isArray","baseColorFactor","array","baseColorTexture","push","assignTexture","index","Promise","all","BINARY_EXTENSION_HEADER_LENGTH","BINARY_EXTENSION_CHUNK_TYPES","BIN","body","headerView","DataView","header","slice","getUint32","length","chunkView","chunkIndex","byteLength","chunkLength","chunkType","contentArray","byteOffset","decodePrimitive","primitive","bufferViewIndex","bufferView","gltfAttributeMap","attributes","threeAttributeMap","attributeName","ATTRIBUTES","getDependency","then","resolve","decodeDracoFile","specularGlossinessParams","ShaderMaterial","params","pbrSpecularGlossiness","shader","ShaderLib","uniforms","UniformsUtils","clone","specularMapParsFragmentChunk","join","glossinessMapParsFragmentChunk","specularMapFragmentChunk","glossinessMapFragmentChunk","lightPhysicalFragmentChunk","fragmentShader","replace","roughness","metalness","roughnessMap","metalnessMap","specular","setHex","glossiness","specularMap","glossinessMap","vertexShader","defines","diffuseFactor","diffuseTexture","emissive","glossinessFactor","specularFactor","specularGlossinessTexture","specGlossIndex","createMaterial","fog","transparent","isGLTFSpecularGlossinessMaterial","map","lightMap","lightMapIntensity","aoMap","aoMapIntensity","emissiveIntensity","emissiveMap","bumpMap","bumpScale","normalMap","normalScale","displacementMap","displacementScale","displacementBias","alphaMap","envMap","envMapIntensity","refractionRatio","derivatives","cloneMaterial","source","i","il","refreshUniforms","renderer","camera","geometry","group","diffuse","copy","multiplyScalar","uvScaleMap","isWebGLRenderTarget","texture","offset","repeat","matrix","matrixAutoUpdate","rotation","center","setUvTransform","x","y","uvTransform","offsetRepeat","flipEnvMap","isCubeTexture","USE_GLOSSINESSMAP","USE_ROUGHNESSMAP","GLTFCubicSplineInterpolant","parameterPositions","sampleValues","sampleSize","resultBuffer","Interpolant","call","Object","create","interpolate_","i1","t0","t","t1","result","values","stride","valueSize","stride2","stride3","td","p","pp","ppp","offset1","offset0","s0","s1","s2","s3","p0","m0","p1","m1","WEBGL_CONSTANTS","FLOAT","FLOAT_MAT3","FLOAT_MAT4","FLOAT_VEC2","FLOAT_VEC3","FLOAT_VEC4","LINEAR","REPEAT","SAMPLER_2D","POINTS","LINES","LINE_LOOP","LINE_STRIP","TRIANGLES","TRIANGLE_STRIP","TRIANGLE_FAN","UNSIGNED_BYTE","UNSIGNED_SHORT","WEBGL_COMPONENT_TYPES","Int8Array","Int16Array","Uint16Array","Uint32Array","Float32Array","WEBGL_FILTERS","NearestFilter","LinearFilter","NearestMipMapNearestFilter","LinearMipMapNearestFilter","NearestMipMapLinearFilter","LinearMipMapLinearFilter","WEBGL_WRAPPINGS","ClampToEdgeWrapping","MirroredRepeatWrapping","RepeatWrapping","WEBGL_TEXTURE_FORMATS","AlphaFormat","RGBFormat","RGBAFormat","LuminanceFormat","LuminanceAlphaFormat","WEBGL_TEXTURE_DATATYPES","UnsignedByteType","UnsignedShort4444Type","UnsignedShort5551Type","UnsignedShort565Type","WEBGL_TYPE_SIZES","POSITION","NORMAL","TEXCOORD_0","TEXCOORD0","TEXCOORD","TEXCOORD_1","COLOR_0","COLOR0","COLOR","WEIGHTS_0","WEIGHT","JOINTS_0","JOINT","PATH_PROPERTIES","scale","translation","weights","INTERPOLATION","CUBICSPLINE","InterpolateSmooth","InterpolateLinear","STEP","InterpolateDiscrete","ALPHA_MODES","OPAQUE","MASK","BLEND","resolveURL","test","createDefaultMaterial","MeshStandardMaterial","depthTest","side","FrontSide","addMorphTargets","mesh","meshDef","primitiveDef","accessors","targets","hasMorphPosition","hasMorphNormal","morphPositions","morphNormals","positionAttribute","cloneBufferAttribute","j","jl","count","setXYZ","getX","getY","getZ","normalAttribute","normal","morphAttributes","updateMorphTargets","morphTargetInfluences","extras","targetNames","morphTargetDictionary","console","warn","isPrimitiveEqual","a","b","indices","attribA","attribB","keysA","keys","keysB","getCachedGeometry","cache","newPrimitive","cached","promise","attribute","isInterleavedBufferAttribute","itemSize","getW","BufferAttribute","normalized","options","primitiveCache","textureLoader","TextureLoader","fileLoader","markDefs","getMultiDependencies","dependencies","catch","nodeDefs","nodes","skinDefs","skins","meshDefs","meshes","meshReferences","meshUses","skinIndex","skinLength","joints","isBone","nodeIndex","nodeLength","nodeDef","skin","isSkinnedMesh","cacheKey","dependency","loadScene","loadNode","loadMesh","loadAccessor","loadBufferView","loadBuffer","loadMaterial","loadTexture","loadSkin","loadAnimation","loadCamera","getDependencies","defs","def","types","results","pendings","bind","bufferIndex","bufferDef","buffers","uri","reject","bufferViewDef","bufferViews","buffer","accessorIndex","accessorDef","sparse","pendingBufferViews","TypedArray","componentType","elementBytes","BYTES_PER_ELEMENT","itemBytes","byteStride","bufferAttribute","ibCacheKey","ib","InterleavedBuffer","InterleavedBufferAttribute","itemSizeIndices","SCALAR","TypedArrayIndices","byteOffsetIndices","byteOffsetValues","sparseIndices","sparseValues","setArray","setX","setY","setZ","setW","textureIndex","URL","window","webkitURL","textureDef","textures","textureExtensions","images","sourceURI","isObjectURL","blob","Blob","mimeType","createObjectURL","Loader","Handlers","revokeObjectURL","flipY","format","internalFormat","samplers","sampler","magFilter","minFilter","wrapS","wrapT","textureName","materialIndex","materialDef","materials","materialType","materialExtensions","sgExtension","kmuExtension","metallicFactor","roughnessFactor","metallicRoughnessTexture","doubleSided","DoubleSide","alphaMode","alphaTest","alphaCutoff","normalTexture","Vector2","occlusionTexture","strength","emissiveFactor","emissiveTexture","encoding","sRGBEncoding","userData","addPrimitiveAttributes","gltfAttributeName","threeAttributeName","addAttribute","setIndex","loadGeometries","primitives","addPrimitives","geometryPromise","BufferGeometry","meshIndex","Group","geometries","uv2","uv","log","useVertexColors","useFlatShading","useSkinning","useMorphTargets","specGlossExtension","vertexColors","VertexColors","needsUpdate","flatShading","mode","SkinnedMesh","skinning","Mesh","drawMode","TriangleStripDrawMode","TriangleFanDrawMode","uuid","lineMaterial","LineBasicMaterial","Material","LineSegments","Line","LineLoop","pointsMaterial","PointsMaterial","Points","morphTargets","onBeforeRender","cameraIndex","cameraDef","PerspectiveCamera","radToDeg","yfov","aspectRatio","znear","zfar","OrthographicCamera","xmag","ymag","skinDef","skinEntry","inverseBindMatrices","accessor","animationIndex","animationDef","tracks","pushToTargetNames","isMesh","channels","channel","node","id","input","parameters","output","inputAccessor","outputAccessor","updateMatrix","TypedKeyframeTrack","NumberKeyframeTrack","QuaternionKeyframeTrack","VectorKeyframeTrack","targetName","interpolation","traverse","track","AnimationUtils","arraySlice","createInterpolant","InterpolantFactoryMethodGLTFCubicSpline","times","getValueSize","isInterpolantFactoryMethodGLTFCubicSpline","AnimationClip","Bone","isGroup","children","child","Object3D","PropertyBinding","sanitizeNodeName","Matrix4","applyMatrix","quaternion","buildNodeHierachy","nodeId","parentObject","allNodes","bones","boneInverses","jointId","jointNode","mat","Skeleton","matrixWorld","sceneIndex","sceneDef","Scene","nodeIds"],"mappings":"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","sourcesContent":["import * as THREE from 'three';\nimport DDSLoader from \"./dds-loader\";\n\n/**\n * @author Rich Tibbett / https://github.com/richtr\n * @author mrdoob / http://mrdoob.com/\n * @author Tony Parisi / http://www.tonyparisi.com/\n * @author Takahiro / https://github.com/takahirox\n * @author Don McCurdy / https://www.donmccurdy.com\n */\n\nconst GLTFLoader = ( function () {\n\n\tfunction GLTFLoader( manager ) {\n\n\t\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\t\tthis.dracoLoader = null;\n\n\t}\n\n\tGLTFLoader.prototype = {\n\n\t\tconstructor: GLTFLoader,\n\n\t\tcrossOrigin: 'Anonymous',\n\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tvar scope = this;\n\n\t\t\tvar path = this.path !== undefined ? this.path : THREE.LoaderUtils.extractUrlBase( url );\n\n\t\t\tvar loader = new THREE.FileLoader( scope.manager );\n\n\t\t\tloader.setResponseType( 'arraybuffer' );\n\n\t\t\tloader.load( url, function ( data ) {\n\n\t\t\t\ttry {\n\n\t\t\t\t\tscope.parse( data, path, onLoad, onError );\n\n\t\t\t\t} catch ( e ) {\n\n\t\t\t\t\tif ( onError !== undefined ) {\n\n\t\t\t\t\t\tonError( e );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthrow e;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}, onProgress, onError );\n\n\t\t},\n\n\t\tsetCrossOrigin: function ( value ) {\n\n\t\t\tthis.crossOrigin = value;\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetPath: function ( value ) {\n\n\t\t\tthis.path = value;\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetDRACOLoader: function ( dracoLoader ) {\n\n\t\t\tthis.dracoLoader = dracoLoader;\n\t\t\treturn this;\n\n\t\t},\n\n\t\tparse: function ( data, path, onLoad, onError ) {\n\n\t\t\tvar content;\n\t\t\tvar extensions = {};\n\n\t\t\tif ( typeof data === 'string' ) {\n\n\t\t\t\tcontent = data;\n\n\t\t\t} else {\n\n\t\t\t\tvar magic = THREE.LoaderUtils.decodeText( new Uint8Array( data, 0, 4 ) );\n\n\t\t\t\tif ( magic === BINARY_EXTENSION_HEADER_MAGIC ) {\n\n\t\t\t\t\ttry {\n\n\t\t\t\t\t\textensions[ EXTENSIONS.KHR_BINARY_GLTF ] = new GLTFBinaryExtension( data );\n\n\t\t\t\t\t} catch ( error ) {\n\n\t\t\t\t\t\tif ( onError ) onError( error );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tcontent = extensions[ EXTENSIONS.KHR_BINARY_GLTF ].content;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tcontent = THREE.LoaderUtils.decodeText( new Uint8Array( data ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar json = JSON.parse( content );\n\n\t\t\tif ( json.asset === undefined || json.asset.version[ 0 ] < 2 ) {\n\n\t\t\t\tif ( onError ) onError( new Error( 'THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported. Use LegacyGLTFLoader instead.' ) );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tif ( json.extensionsUsed ) {\n\n\t\t\t\tif ( json.extensionsUsed.indexOf( EXTENSIONS.KHR_LIGHTS ) >= 0 ) {\n\n\t\t\t\t\textensions[ EXTENSIONS.KHR_LIGHTS ] = new GLTFLightsExtension( json );\n\n\t\t\t\t}\n\n\t\t\t\tif ( json.extensionsUsed.indexOf( EXTENSIONS.KHR_MATERIALS_UNLIT ) >= 0 ) {\n\n\t\t\t\t\textensions[ EXTENSIONS.KHR_MATERIALS_UNLIT ] = new GLTFMaterialsUnlitExtension( json );\n\n\t\t\t\t}\n\n\t\t\t\tif ( json.extensionsUsed.indexOf( EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ) >= 0 ) {\n\n\t\t\t\t\textensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ] = new GLTFMaterialsPbrSpecularGlossinessExtension();\n\n\t\t\t\t}\n\n\t\t\t\tif ( json.extensionsUsed.indexOf( EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ) >= 0 ) {\n\n\t\t\t\t\textensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ] = new GLTFDracoMeshCompressionExtension( this.dracoLoader );\n\n\t\t\t\t}\n\n\t\t\t\tif ( json.extensionsUsed.indexOf( EXTENSIONS.MSFT_TEXTURE_DDS ) >= 0 ) {\n\n\t\t\t\t\textensions[ EXTENSIONS.MSFT_TEXTURE_DDS ] = new GLTFTextureDDSExtension();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar parser = new GLTFParser( json, extensions, {\n\n\t\t\t\tpath: path || this.path || '',\n\t\t\t\tcrossOrigin: this.crossOrigin,\n\t\t\t\tmanager: this.manager\n\n\t\t\t} );\n\n\t\t\tparser.parse( function ( scene, scenes, cameras, animations, asset ) {\n\n\t\t\t\tvar glTF = {\n\t\t\t\t\tscene: scene,\n\t\t\t\t\tscenes: scenes,\n\t\t\t\t\tcameras: cameras,\n\t\t\t\t\tanimations: animations,\n\t\t\t\t\tasset: asset\n\t\t\t\t};\n\n\t\t\t\tonLoad( glTF );\n\n\t\t\t}, onError );\n\n\t\t}\n\n\t};\n\n\t/* GLTFREGISTRY */\n\n\tfunction GLTFRegistry() {\n\n\t\tvar objects = {};\n\n\t\treturn\t{\n\n\t\t\tget: function ( key ) {\n\n\t\t\t\treturn objects[ key ];\n\n\t\t\t},\n\n\t\t\tadd: function ( key, object ) {\n\n\t\t\t\tobjects[ key ] = object;\n\n\t\t\t},\n\n\t\t\tremove: function ( key ) {\n\n\t\t\t\tdelete objects[ key ];\n\n\t\t\t},\n\n\t\t\tremoveAll: function () {\n\n\t\t\t\tobjects = {};\n\n\t\t\t}\n\n\t\t};\n\n\t}\n\n\t/*********************************/\n\t/********** EXTENSIONS ***********/\n\t/*********************************/\n\n\tvar EXTENSIONS = {\n\t\tKHR_BINARY_GLTF: 'KHR_binary_glTF',\n\t\tKHR_DRACO_MESH_COMPRESSION: 'KHR_draco_mesh_compression',\n\t\tKHR_LIGHTS: 'KHR_lights',\n\t\tKHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: 'KHR_materials_pbrSpecularGlossiness',\n\t\tKHR_MATERIALS_UNLIT: 'KHR_materials_unlit',\n\t\tMSFT_TEXTURE_DDS: 'MSFT_texture_dds'\n\t};\n\n\t/**\n\t * DDS Texture Extension\n\t *\n\t * Specification: \n\t * https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/MSFT_texture_dds\n\t * \n\t */\n\tfunction GLTFTextureDDSExtension() {\n\n\t\tif (!DDSLoader ) {\n\n\t\t\tthrow new Error( 'THREE.GLTFLoader: Attempting to load .dds texture without importing THREE.DDSLoader' );\n\n\t\t}\n\n\t\tthis.name = EXTENSIONS.MSFT_TEXTURE_DDS;\n\t\tthis.ddsLoader = new DDSLoader();\n\n\t}\n\n\t/**\n\t * Lights Extension\n\t *\n\t * Specification: PENDING\n\t */\n\tfunction GLTFLightsExtension( json ) {\n\n\t\tthis.name = EXTENSIONS.KHR_LIGHTS;\n\n\t\tthis.lights = {};\n\n\t\tvar extension = ( json.extensions && json.extensions[ EXTENSIONS.KHR_LIGHTS ] ) || {};\n\t\tvar lights = extension.lights || {};\n\n\t\tfor ( var lightId in lights ) {\n\n\t\t\tvar light = lights[ lightId ];\n\t\t\tvar lightNode;\n\n\t\t\tvar color = new THREE.Color().fromArray( light.color );\n\n\t\t\tswitch ( light.type ) {\n\n\t\t\t\tcase 'directional':\n\t\t\t\t\tlightNode = new THREE.DirectionalLight( color );\n\t\t\t\t\tlightNode.target.position.set( 0, 0, 1 );\n\t\t\t\t\tlightNode.add( lightNode.target );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'point':\n\t\t\t\t\tlightNode = new THREE.PointLight( color );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'spot':\n\t\t\t\t\tlightNode = new THREE.SpotLight( color );\n\t\t\t\t\t// Handle spotlight properties.\n\t\t\t\t\tlight.spot = light.spot || {};\n\t\t\t\t\tlight.spot.innerConeAngle = light.spot.innerConeAngle !== undefined ? light.spot.innerConeAngle : 0;\n\t\t\t\t\tlight.spot.outerConeAngle = light.spot.outerConeAngle !== undefined ? light.spot.outerConeAngle : Math.PI / 4.0;\n\t\t\t\t\tlightNode.angle = light.spot.outerConeAngle;\n\t\t\t\t\tlightNode.penumbra = 1.0 - light.spot.innerConeAngle / light.spot.outerConeAngle;\n\t\t\t\t\tlightNode.target.position.set( 0, 0, 1 );\n\t\t\t\t\tlightNode.add( lightNode.target );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ambient':\n\t\t\t\t\tlightNode = new THREE.AmbientLight( color );\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t}\n\n\t\t\tif ( lightNode ) {\n\n\t\t\t\tlightNode.decay = 2;\n\n\t\t\t\tif ( light.intensity !== undefined ) {\n\n\t\t\t\t\tlightNode.intensity = light.intensity;\n\n\t\t\t\t}\n\n\t\t\t\tlightNode.name = light.name || ( 'light_' + lightId );\n\t\t\t\tthis.lights[ lightId ] = lightNode;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Unlit Materials Extension (pending)\n\t *\n\t * PR: https://github.com/KhronosGroup/glTF/pull/1163\n\t */\n\tfunction GLTFMaterialsUnlitExtension( json ) {\n\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_UNLIT;\n\n\t}\n\n\tGLTFMaterialsUnlitExtension.prototype.getMaterialType = function ( material ) {\n\n\t\treturn THREE.MeshBasicMaterial;\n\n\t};\n\n\tGLTFMaterialsUnlitExtension.prototype.extendParams = function ( materialParams, material, parser ) {\n\n\t\tvar pending = [];\n\n\t\tmaterialParams.color = new THREE.Color( 1.0, 1.0, 1.0 );\n\t\tmaterialParams.opacity = 1.0;\n\n\t\tvar metallicRoughness = material.pbrMetallicRoughness;\n\n\t\tif ( metallicRoughness ) {\n\n\t\t\tif ( Array.isArray( metallicRoughness.baseColorFactor ) ) {\n\n\t\t\t\tvar array = metallicRoughness.baseColorFactor;\n\n\t\t\t\tmaterialParams.color.fromArray( array );\n\t\t\t\tmaterialParams.opacity = array[ 3 ];\n\n\t\t\t}\n\n\t\t\tif ( metallicRoughness.baseColorTexture !== undefined ) {\n\n\t\t\t\tpending.push( parser.assignTexture( materialParams, 'map', metallicRoughness.baseColorTexture.index ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn Promise.all( pending );\n\n\t};\n\n\t/* BINARY EXTENSION */\n\n\tvar BINARY_EXTENSION_HEADER_MAGIC = 'glTF';\n\tvar BINARY_EXTENSION_HEADER_LENGTH = 12;\n\tvar BINARY_EXTENSION_CHUNK_TYPES = { JSON: 0x4E4F534A, BIN: 0x004E4942 };\n\n\tfunction GLTFBinaryExtension( data ) {\n\n\t\tthis.name = EXTENSIONS.KHR_BINARY_GLTF;\n\t\tthis.content = null;\n\t\tthis.body = null;\n\n\t\tvar headerView = new DataView( data, 0, BINARY_EXTENSION_HEADER_LENGTH );\n\n\t\tthis.header = {\n\t\t\tmagic: THREE.LoaderUtils.decodeText( new Uint8Array( data.slice( 0, 4 ) ) ),\n\t\t\tversion: headerView.getUint32( 4, true ),\n\t\t\tlength: headerView.getUint32( 8, true )\n\t\t};\n\n\t\tif ( this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC ) {\n\n\t\t\tthrow new Error( 'THREE.GLTFLoader: Unsupported glTF-Binary header.' );\n\n\t\t} else if ( this.header.version < 2.0 ) {\n\n\t\t\tthrow new Error( 'THREE.GLTFLoader: Legacy binary file detected. Use LegacyGLTFLoader instead.' );\n\n\t\t}\n\n\t\tvar chunkView = new DataView( data, BINARY_EXTENSION_HEADER_LENGTH );\n\t\tvar chunkIndex = 0;\n\n\t\twhile ( chunkIndex < chunkView.byteLength ) {\n\n\t\t\tvar chunkLength = chunkView.getUint32( chunkIndex, true );\n\t\t\tchunkIndex += 4;\n\n\t\t\tvar chunkType = chunkView.getUint32( chunkIndex, true );\n\t\t\tchunkIndex += 4;\n\n\t\t\tif ( chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON ) {\n\n\t\t\t\tvar contentArray = new Uint8Array( data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength );\n\t\t\t\tthis.content = THREE.LoaderUtils.decodeText( contentArray );\n\n\t\t\t} else if ( chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN ) {\n\n\t\t\t\tvar byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;\n\t\t\t\tthis.body = data.slice( byteOffset, byteOffset + chunkLength );\n\n\t\t\t}\n\n\t\t\t// Clients must ignore chunks with unknown types.\n\n\t\t\tchunkIndex += chunkLength;\n\n\t\t}\n\n\t\tif ( this.content === null ) {\n\n\t\t\tthrow new Error( 'THREE.GLTFLoader: JSON content not found.' );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * DRACO Mesh Compression Extension\n\t *\n\t * Specification: https://github.com/KhronosGroup/glTF/pull/874\n\t */\n\tfunction GLTFDracoMeshCompressionExtension ( dracoLoader ) {\n\n\t\tif ( ! dracoLoader ) {\n\n\t\t\tthrow new Error( 'THREE.GLTFLoader: No DRACOLoader instance provided.' );\n\n\t\t}\n\n\t\tthis.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;\n\t\tthis.dracoLoader = dracoLoader;\n\n\t}\n\n\tGLTFDracoMeshCompressionExtension.prototype.decodePrimitive = function ( primitive, parser ) {\n\n\t\tvar dracoLoader = this.dracoLoader;\n\t\tvar bufferViewIndex = primitive.extensions[ this.name ].bufferView;\n\t\tvar gltfAttributeMap = primitive.extensions[ this.name ].attributes;\n\t\tvar threeAttributeMap = {};\n\n\t\tfor ( var attributeName in gltfAttributeMap ) {\n\n\t\t\tif ( !( attributeName in ATTRIBUTES ) ) continue;\n\n\t\t\tthreeAttributeMap[ ATTRIBUTES[ attributeName ] ] = gltfAttributeMap[ attributeName ];\n\n\t\t}\n\n\t\treturn parser.getDependency( 'bufferView', bufferViewIndex ).then( function ( bufferView ) {\n\n\t\t\treturn new Promise( function ( resolve ) {\n\n\t\t\t\tdracoLoader.decodeDracoFile( bufferView, resolve, threeAttributeMap );\n\n\t\t\t} );\n\n\t\t} );\n\n\t};\n\n\t/**\n\t * Specular-Glossiness Extension\n\t *\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness\n\t */\n\tfunction GLTFMaterialsPbrSpecularGlossinessExtension() {\n\n\t\treturn {\n\n\t\t\tname: EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS,\n\n\t\t\tspecularGlossinessParams: [\n\t\t\t\t'color',\n\t\t\t\t'map',\n\t\t\t\t'lightMap',\n\t\t\t\t'lightMapIntensity',\n\t\t\t\t'aoMap',\n\t\t\t\t'aoMapIntensity',\n\t\t\t\t'emissive',\n\t\t\t\t'emissiveIntensity',\n\t\t\t\t'emissiveMap',\n\t\t\t\t'bumpMap',\n\t\t\t\t'bumpScale',\n\t\t\t\t'normalMap',\n\t\t\t\t'displacementMap',\n\t\t\t\t'displacementScale',\n\t\t\t\t'displacementBias',\n\t\t\t\t'specularMap',\n\t\t\t\t'specular',\n\t\t\t\t'glossinessMap',\n\t\t\t\t'glossiness',\n\t\t\t\t'alphaMap',\n\t\t\t\t'envMap',\n\t\t\t\t'envMapIntensity',\n\t\t\t\t'refractionRatio',\n\t\t\t],\n\n\t\t\tgetMaterialType: function () {\n\n\t\t\t\treturn THREE.ShaderMaterial;\n\n\t\t\t},\n\n\t\t\textendParams: function ( params, material, parser ) {\n\n\t\t\t\tvar pbrSpecularGlossiness = material.extensions[ this.name ];\n\n\t\t\t\tvar shader = THREE.ShaderLib[ 'standard' ];\n\n\t\t\t\tvar uniforms = THREE.UniformsUtils.clone( shader.uniforms );\n\n\t\t\t\tvar specularMapParsFragmentChunk = [\n\t\t\t\t\t'#ifdef USE_SPECULARMAP',\n\t\t\t\t\t'\tuniform sampler2D specularMap;',\n\t\t\t\t\t'#endif'\n\t\t\t\t].join( '\\n' );\n\n\t\t\t\tvar glossinessMapParsFragmentChunk = [\n\t\t\t\t\t'#ifdef USE_GLOSSINESSMAP',\n\t\t\t\t\t'\tuniform sampler2D glossinessMap;',\n\t\t\t\t\t'#endif'\n\t\t\t\t].join( '\\n' );\n\n\t\t\t\tvar specularMapFragmentChunk = [\n\t\t\t\t\t'vec3 specularFactor = specular;',\n\t\t\t\t\t'#ifdef USE_SPECULARMAP',\n\t\t\t\t\t'\tvec4 texelSpecular = texture2D( specularMap, vUv );',\n\t\t\t\t\t'\ttexelSpecular = sRGBToLinear( texelSpecular );',\n\t\t\t\t\t'\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture',\n\t\t\t\t\t'\tspecularFactor *= texelSpecular.rgb;',\n\t\t\t\t\t'#endif'\n\t\t\t\t].join( '\\n' );\n\n\t\t\t\tvar glossinessMapFragmentChunk = [\n\t\t\t\t\t'float glossinessFactor = glossiness;',\n\t\t\t\t\t'#ifdef USE_GLOSSINESSMAP',\n\t\t\t\t\t'\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );',\n\t\t\t\t\t'\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture',\n\t\t\t\t\t'\tglossinessFactor *= texelGlossiness.a;',\n\t\t\t\t\t'#endif'\n\t\t\t\t].join( '\\n' );\n\n\t\t\t\tvar lightPhysicalFragmentChunk = [\n\t\t\t\t\t'PhysicalMaterial material;',\n\t\t\t\t\t'material.diffuseColor = diffuseColor.rgb;',\n\t\t\t\t\t'material.specularRoughness = clamp( 1.0 - glossinessFactor, 0.04, 1.0 );',\n\t\t\t\t\t'material.specularColor = specularFactor.rgb;',\n\t\t\t\t].join( '\\n' );\n\n\t\t\t\tvar fragmentShader = shader.fragmentShader\n\t\t\t\t\t.replace( '#include <specularmap_fragment>', '' )\n\t\t\t\t\t.replace( 'uniform float roughness;', 'uniform vec3 specular;' )\n\t\t\t\t\t.replace( 'uniform float metalness;', 'uniform float glossiness;' )\n\t\t\t\t\t.replace( '#include <roughnessmap_pars_fragment>', specularMapParsFragmentChunk )\n\t\t\t\t\t.replace( '#include <metalnessmap_pars_fragment>', glossinessMapParsFragmentChunk )\n\t\t\t\t\t.replace( '#include <roughnessmap_fragment>', specularMapFragmentChunk )\n\t\t\t\t\t.replace( '#include <metalnessmap_fragment>', glossinessMapFragmentChunk )\n\t\t\t\t\t.replace( '#include <lights_physical_fragment>', lightPhysicalFragmentChunk );\n\n\t\t\t\tdelete uniforms.roughness;\n\t\t\t\tdelete uniforms.metalness;\n\t\t\t\tdelete uniforms.roughnessMap;\n\t\t\t\tdelete uniforms.metalnessMap;\n\n\t\t\t\tuniforms.specular = { value: new THREE.Color().setHex( 0x111111 ) };\n\t\t\t\tuniforms.glossiness = { value: 0.5 };\n\t\t\t\tuniforms.specularMap = { value: null };\n\t\t\t\tuniforms.glossinessMap = { value: null };\n\n\t\t\t\tparams.vertexShader = shader.vertexShader;\n\t\t\t\tparams.fragmentShader = fragmentShader;\n\t\t\t\tparams.uniforms = uniforms;\n\t\t\t\tparams.defines = { 'STANDARD': '' };\n\n\t\t\t\tparams.color = new THREE.Color( 1.0, 1.0, 1.0 );\n\t\t\t\tparams.opacity = 1.0;\n\n\t\t\t\tvar pending = [];\n\n\t\t\t\tif ( Array.isArray( pbrSpecularGlossiness.diffuseFactor ) ) {\n\n\t\t\t\t\tvar array = pbrSpecularGlossiness.diffuseFactor;\n\n\t\t\t\t\tparams.color.fromArray( array );\n\t\t\t\t\tparams.opacity = array[ 3 ];\n\n\t\t\t\t}\n\n\t\t\t\tif ( pbrSpecularGlossiness.diffuseTexture !== undefined ) {\n\n\t\t\t\t\tpending.push( parser.assignTexture( params, 'map', pbrSpecularGlossiness.diffuseTexture.index ) );\n\n\t\t\t\t}\n\n\t\t\t\tparams.emissive = new THREE.Color( 0.0, 0.0, 0.0 );\n\t\t\t\tparams.glossiness = pbrSpecularGlossiness.glossinessFactor !== undefined ? pbrSpecularGlossiness.glossinessFactor : 1.0;\n\t\t\t\tparams.specular = new THREE.Color( 1.0, 1.0, 1.0 );\n\n\t\t\t\tif ( Array.isArray( pbrSpecularGlossiness.specularFactor ) ) {\n\n\t\t\t\t\tparams.specular.fromArray( pbrSpecularGlossiness.specularFactor );\n\n\t\t\t\t}\n\n\t\t\t\tif ( pbrSpecularGlossiness.specularGlossinessTexture !== undefined ) {\n\n\t\t\t\t\tvar specGlossIndex = pbrSpecularGlossiness.specularGlossinessTexture.index;\n\t\t\t\t\tpending.push( parser.assignTexture( params, 'glossinessMap', specGlossIndex ) );\n\t\t\t\t\tpending.push( parser.assignTexture( params, 'specularMap', specGlossIndex ) );\n\n\t\t\t\t}\n\n\t\t\t\treturn Promise.all( pending );\n\n\t\t\t},\n\n\t\t\tcreateMaterial: function ( params ) {\n\n\t\t\t\t// setup material properties based on MeshStandardMaterial for Specular-Glossiness\n\n\t\t\t\tvar material = new THREE.ShaderMaterial( {\n\t\t\t\t\tdefines: params.defines,\n\t\t\t\t\tvertexShader: params.vertexShader,\n\t\t\t\t\tfragmentShader: params.fragmentShader,\n\t\t\t\t\tuniforms: params.uniforms,\n\t\t\t\t\tfog: true,\n\t\t\t\t\tlights: true,\n\t\t\t\t\topacity: params.opacity,\n\t\t\t\t\ttransparent: params.transparent\n\t\t\t\t} );\n\n\t\t\t\tmaterial.isGLTFSpecularGlossinessMaterial = true;\n\n\t\t\t\tmaterial.color = params.color;\n\n\t\t\t\tmaterial.map = params.map === undefined ? null : params.map;\n\n\t\t\t\tmaterial.lightMap = null;\n\t\t\t\tmaterial.lightMapIntensity = 1.0;\n\n\t\t\t\tmaterial.aoMap = params.aoMap === undefined ? null : params.aoMap;\n\t\t\t\tmaterial.aoMapIntensity = 1.0;\n\n\t\t\t\tmaterial.emissive = params.emissive;\n\t\t\t\tmaterial.emissiveIntensity = 1.0;\n\t\t\t\tmaterial.emissiveMap = params.emissiveMap === undefined ? null : params.emissiveMap;\n\n\t\t\t\tmaterial.bumpMap = params.bumpMap === undefined ? null : params.bumpMap;\n\t\t\t\tmaterial.bumpScale = 1;\n\n\t\t\t\tmaterial.normalMap = params.normalMap === undefined ? null : params.normalMap;\n\t\t\t\tif ( params.normalScale ) material.normalScale = params.normalScale;\n\n\t\t\t\tmaterial.displacementMap = null;\n\t\t\t\tmaterial.displacementScale = 1;\n\t\t\t\tmaterial.displacementBias = 0;\n\n\t\t\t\tmaterial.specularMap = params.specularMap === undefined ? null : params.specularMap;\n\t\t\t\tmaterial.specular = params.specular;\n\n\t\t\t\tmaterial.glossinessMap = params.glossinessMap === undefined ? null : params.glossinessMap;\n\t\t\t\tmaterial.glossiness = params.glossiness;\n\n\t\t\t\tmaterial.alphaMap = null;\n\n\t\t\t\tmaterial.envMap = params.envMap === undefined ? null : params.envMap;\n\t\t\t\tmaterial.envMapIntensity = 1.0;\n\n\t\t\t\tmaterial.refractionRatio = 0.98;\n\n\t\t\t\tmaterial.extensions.derivatives = true;\n\n\t\t\t\treturn material;\n\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Clones a GLTFSpecularGlossinessMaterial instance. The ShaderMaterial.copy() method can\n\t\t\t * copy only properties it knows about or inherits, and misses many properties that would\n\t\t\t * normally be defined by MeshStandardMaterial.\n\t\t\t *\n\t\t\t * This method allows GLTFSpecularGlossinessMaterials to be cloned in the process of\n\t\t\t * loading a glTF model, but cloning later (e.g. by the user) would require these changes\n\t\t\t * AND also updating `.onBeforeRender` on the parent mesh.\n\t\t\t *\n\t\t\t * @param  {THREE.ShaderMaterial} source\n\t\t\t * @return {THREE.ShaderMaterial}\n\t\t\t */\n\t\t\tcloneMaterial: function ( source ) {\n\n\t\t\t\tvar target = source.clone();\n\n\t\t\t\ttarget.isGLTFSpecularGlossinessMaterial = true;\n\n\t\t\t\tvar params = this.specularGlossinessParams;\n\n\t\t\t\tfor ( var i = 0, il = params.length; i < il; i ++ ) {\n\n\t\t\t\t\ttarget[ params[ i ] ] = source[ params[ i ] ];\n\n\t\t\t\t}\n\n\t\t\t\treturn target;\n\n\t\t\t},\n\n\t\t\t// Here's based on refreshUniformsCommon() and refreshUniformsStandard() in WebGLRenderer.\n\t\t\trefreshUniforms: function ( renderer, scene, camera, geometry, material, group ) {\n\n\t\t\t\tif ( material.isGLTFSpecularGlossinessMaterial !== true ) {\n\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tvar uniforms = material.uniforms;\n\t\t\t\tvar defines = material.defines;\n\n\t\t\t\tuniforms.opacity.value = material.opacity;\n\n\t\t\t\tuniforms.diffuse.value.copy( material.color );\n\t\t\t\tuniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity );\n\n\t\t\t\tuniforms.map.value = material.map;\n\t\t\t\tuniforms.specularMap.value = material.specularMap;\n\t\t\t\tuniforms.alphaMap.value = material.alphaMap;\n\n\t\t\t\tuniforms.lightMap.value = material.lightMap;\n\t\t\t\tuniforms.lightMapIntensity.value = material.lightMapIntensity;\n\n\t\t\t\tuniforms.aoMap.value = material.aoMap;\n\t\t\t\tuniforms.aoMapIntensity.value = material.aoMapIntensity;\n\n\t\t\t\t// uv repeat and offset setting priorities\n\t\t\t\t// 1. color map\n\t\t\t\t// 2. specular map\n\t\t\t\t// 3. normal map\n\t\t\t\t// 4. bump map\n\t\t\t\t// 5. alpha map\n\t\t\t\t// 6. emissive map\n\n\t\t\t\tvar uvScaleMap;\n\n\t\t\t\tif ( material.map ) {\n\n\t\t\t\t\tuvScaleMap = material.map;\n\n\t\t\t\t} else if ( material.specularMap ) {\n\n\t\t\t\t\tuvScaleMap = material.specularMap;\n\n\t\t\t\t} else if ( material.displacementMap ) {\n\n\t\t\t\t\tuvScaleMap = material.displacementMap;\n\n\t\t\t\t} else if ( material.normalMap ) {\n\n\t\t\t\t\tuvScaleMap = material.normalMap;\n\n\t\t\t\t} else if ( material.bumpMap ) {\n\n\t\t\t\t\tuvScaleMap = material.bumpMap;\n\n\t\t\t\t} else if ( material.glossinessMap ) {\n\n\t\t\t\t\tuvScaleMap = material.glossinessMap;\n\n\t\t\t\t} else if ( material.alphaMap ) {\n\n\t\t\t\t\tuvScaleMap = material.alphaMap;\n\n\t\t\t\t} else if ( material.emissiveMap ) {\n\n\t\t\t\t\tuvScaleMap = material.emissiveMap;\n\n\t\t\t\t}\n\n\t\t\t\tif ( uvScaleMap !== undefined ) {\n\n\t\t\t\t\t// backwards compatibility\n\t\t\t\t\tif ( uvScaleMap.isWebGLRenderTarget ) {\n\n\t\t\t\t\t\tuvScaleMap = uvScaleMap.texture;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar offset;\n\t\t\t\t\tvar repeat;\n\n\t\t\t\t\tif ( uvScaleMap.matrix !== undefined ) {\n\n\t\t\t\t\t\t// > r88.\n\n\t\t\t\t\t\tif ( uvScaleMap.matrixAutoUpdate === true ) {\n\n\t\t\t\t\t\t\toffset = uvScaleMap.offset;\n\t\t\t\t\t\t\trepeat = uvScaleMap.repeat;\n\t\t\t\t\t\t\tvar rotation = uvScaleMap.rotation;\n\t\t\t\t\t\t\tvar center = uvScaleMap.center;\n\n\t\t\t\t\t\t\tuvScaleMap.matrix.setUvTransform( offset.x, offset.y, repeat.x, repeat.y, rotation, center.x, center.y );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tuniforms.uvTransform.value.copy( uvScaleMap.matrix );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// <= r87. Remove when reasonable.\n\n\t\t\t\t\t\toffset = uvScaleMap.offset;\n\t\t\t\t\t\trepeat = uvScaleMap.repeat;\n\n\t\t\t\t\t\tuniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tuniforms.envMap.value = material.envMap;\n\t\t\t\tuniforms.envMapIntensity.value = material.envMapIntensity;\n\t\t\t\tuniforms.flipEnvMap.value = ( material.envMap && material.envMap.isCubeTexture ) ? - 1 : 1;\n\n\t\t\t\tuniforms.refractionRatio.value = material.refractionRatio;\n\n\t\t\t\tuniforms.specular.value.copy( material.specular );\n\t\t\t\tuniforms.glossiness.value = material.glossiness;\n\n\t\t\t\tuniforms.glossinessMap.value = material.glossinessMap;\n\n\t\t\t\tuniforms.emissiveMap.value = material.emissiveMap;\n\t\t\t\tuniforms.bumpMap.value = material.bumpMap;\n\t\t\t\tuniforms.normalMap.value = material.normalMap;\n\n\t\t\t\tuniforms.displacementMap.value = material.displacementMap;\n\t\t\t\tuniforms.displacementScale.value = material.displacementScale;\n\t\t\t\tuniforms.displacementBias.value = material.displacementBias;\n\n\t\t\t\tif ( uniforms.glossinessMap.value !== null && defines.USE_GLOSSINESSMAP === undefined ) {\n\n\t\t\t\t\tdefines.USE_GLOSSINESSMAP = '';\n\t\t\t\t\t// set USE_ROUGHNESSMAP to enable vUv\n\t\t\t\t\tdefines.USE_ROUGHNESSMAP = '';\n\n\t\t\t\t}\n\n\t\t\t\tif ( uniforms.glossinessMap.value === null && defines.USE_GLOSSINESSMAP !== undefined ) {\n\n\t\t\t\t\tdelete defines.USE_GLOSSINESSMAP;\n\t\t\t\t\tdelete defines.USE_ROUGHNESSMAP;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t}\n\n\t/*********************************/\n\t/********** INTERPOLATION ********/\n\t/*********************************/\n\n\t// Spline Interpolation\n\t// Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#appendix-c-spline-interpolation\n\tfunction GLTFCubicSplineInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\t\tTHREE.Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n\t};\n\n\tGLTFCubicSplineInterpolant.prototype = Object.create( THREE.Interpolant.prototype );\n\tGLTFCubicSplineInterpolant.prototype.constructor = GLTFCubicSplineInterpolant;\n\n\tGLTFCubicSplineInterpolant.prototype.interpolate_ = function ( i1, t0, t, t1 ) {\n\n\t\tvar result = this.resultBuffer;\n\t\tvar values = this.sampleValues;\n\t\tvar stride = this.valueSize;\n\n\t\tvar stride2 = stride * 2;\n\t\tvar stride3 = stride * 3;\n\n\t\tvar td = t1 - t0;\n\n\t\tvar p = ( t - t0 ) / td;\n\t\tvar pp = p * p;\n\t\tvar ppp = pp * p;\n\n\t\tvar offset1 = i1 * stride3;\n\t\tvar offset0 = offset1 - stride3;\n\n\t\tvar s0 = 2 * ppp - 3 * pp + 1;\n\t\tvar s1 = ppp - 2 * pp + p;\n\t\tvar s2 = - 2 * ppp + 3 * pp;\n\t\tvar s3 = ppp - pp;\n\n\t\t// Layout of keyframe output values for CUBICSPLINE animations:\n\t\t//   [ inTangent_1, splineVertex_1, outTangent_1, inTangent_2, splineVertex_2, ... ]\n\t\tfor ( var i = 0; i !== stride; i ++ ) {\n\n\t\t\tvar p0 = values[ offset0 + i + stride ];        // splineVertex_k\n\t\t\tvar m0 = values[ offset0 + i + stride2 ] * td;  // outTangent_k * (t_k+1 - t_k)\n\t\t\tvar p1 = values[ offset1 + i + stride ];        // splineVertex_k+1\n\t\t\tvar m1 = values[ offset1 + i ] * td;            // inTangent_k+1 * (t_k+1 - t_k)\n\n\t\t\tresult[ i ] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;\n\n\t\t}\n\n\t\treturn result;\n\n\t};\n\n\t/*********************************/\n\t/********** INTERNALS ************/\n\t/*********************************/\n\n\t/* CONSTANTS */\n\n\tvar WEBGL_CONSTANTS = {\n\t\tFLOAT: 5126,\n\t\t//FLOAT_MAT2: 35674,\n\t\tFLOAT_MAT3: 35675,\n\t\tFLOAT_MAT4: 35676,\n\t\tFLOAT_VEC2: 35664,\n\t\tFLOAT_VEC3: 35665,\n\t\tFLOAT_VEC4: 35666,\n\t\tLINEAR: 9729,\n\t\tREPEAT: 10497,\n\t\tSAMPLER_2D: 35678,\n\t\tPOINTS: 0,\n\t\tLINES: 1,\n\t\tLINE_LOOP: 2,\n\t\tLINE_STRIP: 3,\n\t\tTRIANGLES: 4,\n\t\tTRIANGLE_STRIP: 5,\n\t\tTRIANGLE_FAN: 6,\n\t\tUNSIGNED_BYTE: 5121,\n\t\tUNSIGNED_SHORT: 5123\n\t};\n\n\tvar WEBGL_COMPONENT_TYPES = {\n\t\t5120: Int8Array,\n\t\t5121: Uint8Array,\n\t\t5122: Int16Array,\n\t\t5123: Uint16Array,\n\t\t5125: Uint32Array,\n\t\t5126: Float32Array\n\t};\n\n\tvar WEBGL_FILTERS = {\n\t\t9728: THREE.NearestFilter,\n\t\t9729: THREE.LinearFilter,\n\t\t9984: THREE.NearestMipMapNearestFilter,\n\t\t9985: THREE.LinearMipMapNearestFilter,\n\t\t9986: THREE.NearestMipMapLinearFilter,\n\t\t9987: THREE.LinearMipMapLinearFilter\n\t};\n\n\tvar WEBGL_WRAPPINGS = {\n\t\t33071: THREE.ClampToEdgeWrapping,\n\t\t33648: THREE.MirroredRepeatWrapping,\n\t\t10497: THREE.RepeatWrapping\n\t};\n\n\tvar WEBGL_TEXTURE_FORMATS = {\n\t\t6406: THREE.AlphaFormat,\n\t\t6407: THREE.RGBFormat,\n\t\t6408: THREE.RGBAFormat,\n\t\t6409: THREE.LuminanceFormat,\n\t\t6410: THREE.LuminanceAlphaFormat\n\t};\n\n\tvar WEBGL_TEXTURE_DATATYPES = {\n\t\t5121: THREE.UnsignedByteType,\n\t\t32819: THREE.UnsignedShort4444Type,\n\t\t32820: THREE.UnsignedShort5551Type,\n\t\t33635: THREE.UnsignedShort565Type\n\t};\n\n\tvar WEBGL_TYPE_SIZES = {\n\t\t'SCALAR': 1,\n\t\t'VEC2': 2,\n\t\t'VEC3': 3,\n\t\t'VEC4': 4,\n\t\t'MAT2': 4,\n\t\t'MAT3': 9,\n\t\t'MAT4': 16\n\t};\n\n\tvar ATTRIBUTES = {\n\t\tPOSITION: 'position',\n\t\tNORMAL: 'normal',\n\t\tTEXCOORD_0: 'uv',\n\t\tTEXCOORD0: 'uv', // deprecated\n\t\tTEXCOORD: 'uv', // deprecated\n\t\tTEXCOORD_1: 'uv2',\n\t\tCOLOR_0: 'color',\n\t\tCOLOR0: 'color', // deprecated\n\t\tCOLOR: 'color', // deprecated\n\t\tWEIGHTS_0: 'skinWeight',\n\t\tWEIGHT: 'skinWeight', // deprecated\n\t\tJOINTS_0: 'skinIndex',\n\t\tJOINT: 'skinIndex' // deprecated\n\t}\n\n\tvar PATH_PROPERTIES = {\n\t\tscale: 'scale',\n\t\ttranslation: 'position',\n\t\trotation: 'quaternion',\n\t\tweights: 'morphTargetInfluences'\n\t};\n\n\tvar INTERPOLATION = {\n\t\tCUBICSPLINE: THREE.InterpolateSmooth, // We use custom interpolation GLTFCubicSplineInterpolation for CUBICSPLINE.\n\t\t                                      // KeyframeTrack.optimize() can't handle glTF Cubic Spline output values layout,\n\t\t                                      // using THREE.InterpolateSmooth for KeyframeTrack instantiation to prevent optimization.\n\t\t                                      // See KeyframeTrack.optimize() for the detail.\n\t\tLINEAR: THREE.InterpolateLinear,\n\t\tSTEP: THREE.InterpolateDiscrete\n\t};\n\n\tvar ALPHA_MODES = {\n\t\tOPAQUE: 'OPAQUE',\n\t\tMASK: 'MASK',\n\t\tBLEND: 'BLEND'\n\t};\n\n\t/* UTILITY FUNCTIONS */\n\n\tfunction resolveURL( url, path ) {\n\n\t\t// Invalid URL\n\t\tif ( typeof url !== 'string' || url === '' ) return '';\n\n\t\t// Absolute URL http://,https://,//\n\t\tif ( /^(https?:)?\\/\\//i.test( url ) ) return url;\n\n\t\t// Data URI\n\t\tif ( /^data:.*,.*$/i.test( url ) ) return url;\n\n\t\t// Blob URL\n\t\tif ( /^blob:.*$/i.test( url ) ) return url;\n\n\t\t// Relative URL\n\t\treturn path + url;\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#default-material\n\t */\n\tfunction createDefaultMaterial() {\n\n\t\treturn new THREE.MeshStandardMaterial( {\n\t\t\tcolor: 0xFFFFFF,\n\t\t\temissive: 0x000000,\n\t\t\tmetalness: 1,\n\t\t\troughness: 1,\n\t\t\ttransparent: false,\n\t\t\tdepthTest: true,\n\t\t\tside: THREE.FrontSide\n\t\t} );\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#morph-targets\n\t *\n\t * @param {THREE.Mesh} mesh\n\t * @param {GLTF.Mesh} meshDef\n\t * @param {GLTF.Primitive} primitiveDef\n\t * @param {Array<THREE.BufferAttribute>} accessors\n\t */\n\tfunction addMorphTargets( mesh, meshDef, primitiveDef, accessors ) {\n\n\t\tvar geometry = mesh.geometry;\n\t\tvar targets = primitiveDef.targets;\n\n\t\tvar hasMorphPosition = false;\n\t\tvar hasMorphNormal = false;\n\n\t\tvar target = null;\n\n\t\tfor ( let i = 0, il = targets.length; i < il; i ++ ) {\n\n\t\t\ttarget = targets[ i ];\n\n\t\t\tif ( target.POSITION !== undefined ) hasMorphPosition = true;\n\t\t\tif ( target.NORMAL !== undefined ) hasMorphNormal = true;\n\n\t\t\tif ( hasMorphPosition && hasMorphNormal ) break;\n\n\t\t}\n\n\t\tif ( ! hasMorphPosition && ! hasMorphNormal ) return;\n\n\t\tvar morphPositions = [];\n\t\tvar morphNormals = [];\n\n\t\tfor ( let i = 0, il = targets.length; i < il; i ++ ) {\n\n\t\t\ttarget = targets[ i ];\n\t\t\tvar attributeName = 'morphTarget' + i;\n\n\t\t\tif ( hasMorphPosition ) {\n\n\t\t\t\t// Three.js morph position is absolute value. The formula is\n\t\t\t\t//   basePosition\n\t\t\t\t//     + weight0 * ( morphPosition0 - basePosition )\n\t\t\t\t//     + weight1 * ( morphPosition1 - basePosition )\n\t\t\t\t//     ...\n\t\t\t\t// while the glTF one is relative\n\t\t\t\t//   basePosition\n\t\t\t\t//     + weight0 * glTFmorphPosition0\n\t\t\t\t//     + weight1 * glTFmorphPosition1\n\t\t\t\t//     ...\n\t\t\t\t// then we need to convert from relative to absolute here.\n\n\t\t\t\tif ( target.POSITION !== undefined ) {\n\n\t\t\t\t\t// Cloning not to pollute original accessor\n\t\t\t\t\tvar positionAttribute = cloneBufferAttribute( accessors[ target.POSITION ] );\n\t\t\t\t\tpositionAttribute.name = attributeName;\n\n\t\t\t\t\tvar position = geometry.attributes.position;\n\n\t\t\t\t\tfor ( var j = 0, jl = positionAttribute.count; j < jl; j ++ ) {\n\n\t\t\t\t\t\tpositionAttribute.setXYZ(\n\t\t\t\t\t\t\tj,\n\t\t\t\t\t\t\tpositionAttribute.getX( j ) + position.getX( j ),\n\t\t\t\t\t\t\tpositionAttribute.getY( j ) + position.getY( j ),\n\t\t\t\t\t\t\tpositionAttribute.getZ( j ) + position.getZ( j )\n\t\t\t\t\t\t);\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tpositionAttribute = geometry.attributes.position;\n\n\t\t\t\t}\n\n\t\t\t\tmorphPositions.push( positionAttribute );\n\n\t\t\t}\n\n\t\t\tif ( hasMorphNormal ) {\n\n\t\t\t\t// see target.POSITION's comment\n\n\t\t\t\tvar normalAttribute;\n\n\t\t\t\tif ( target.NORMAL !== undefined ) {\n\n\t\t\t\t\tnormalAttribute = cloneBufferAttribute( accessors[ target.NORMAL ] );\n\t\t\t\t\tnormalAttribute.name = attributeName;\n\n\t\t\t\t\tvar normal = geometry.attributes.normal;\n\n\t\t\t\t\tfor ( let j = 0, jl = normalAttribute.count; j < jl; j ++ ) {\n\n\t\t\t\t\t\tnormalAttribute.setXYZ(\n\t\t\t\t\t\t\tj,\n\t\t\t\t\t\t\tnormalAttribute.getX( j ) + normal.getX( j ),\n\t\t\t\t\t\t\tnormalAttribute.getY( j ) + normal.getY( j ),\n\t\t\t\t\t\t\tnormalAttribute.getZ( j ) + normal.getZ( j )\n\t\t\t\t\t\t);\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tnormalAttribute = geometry.attributes.normal;\n\n\t\t\t\t}\n\n\t\t\t\tmorphNormals.push( normalAttribute );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( hasMorphPosition ) geometry.morphAttributes.position = morphPositions;\n\t\tif ( hasMorphNormal ) geometry.morphAttributes.normal = morphNormals;\n\n\t\tmesh.updateMorphTargets();\n\n\t\tif ( meshDef.weights !== undefined ) {\n\n\t\t\tfor ( var i = 0, il = meshDef.weights.length; i < il; i ++ ) {\n\n\t\t\t\tmesh.morphTargetInfluences[ i ] = meshDef.weights[ i ];\n\n\t\t\t}\n\n\t\t}\n\n\t\t// .extras has user-defined data, so check that .extras.targetNames is an array.\n\t\tif ( meshDef.extras && Array.isArray( meshDef.extras.targetNames ) ) {\n\n\t\t\tvar targetNames = meshDef.extras.targetNames;\n\n\t\t\tif ( mesh.morphTargetInfluences.length === targetNames.length ) {\n\n\t\t\t\tmesh.morphTargetDictionary = {};\n\n\t\t\t\tfor ( let i = 0, il = targetNames.length; i < il; i ++ ) {\n\n\t\t\t\t\tmesh.morphTargetDictionary[ targetNames[ i ] ] = i;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( 'THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.' );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction isPrimitiveEqual( a, b ) {\n\n\t\tif ( a.indices !== b.indices ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\tvar attribA = a.attributes || {};\n\t\tvar attribB = b.attributes || {};\n\t\tvar keysA = Object.keys( attribA );\n\t\tvar keysB = Object.keys( attribB );\n\n\t\tif ( keysA.length !== keysB.length ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\tfor ( var i = 0, il = keysA.length; i < il; i ++ ) {\n\n\t\t\tvar key = keysA[ i ];\n\n\t\t\tif ( attribA[ key ] !== attribB[ key ] ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\tfunction getCachedGeometry( cache, newPrimitive ) {\n\n\t\tfor ( var i = 0, il = cache.length; i < il; i ++ ) {\n\n\t\t\tvar cached = cache[ i ];\n\n\t\t\tif ( isPrimitiveEqual( cached.primitive, newPrimitive ) ) {\n\n\t\t\t\treturn cached.promise;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n\tfunction cloneBufferAttribute( attribute ) {\n\n\t\tif ( attribute.isInterleavedBufferAttribute ) {\n\n\t\t\tvar count = attribute.count;\n\t\t\tvar itemSize = attribute.itemSize;\n\t\t\tvar array = attribute.array.slice( 0, count * itemSize );\n\n\t\t\tfor ( var i = 0; i < count; ++ i ) {\n\n\t\t\t\tarray[ i ] = attribute.getX( i );\n\t\t\t\tif ( itemSize >= 2 ) array[ i + 1 ] = attribute.getY( i );\n\t\t\t\tif ( itemSize >= 3 ) array[ i + 2 ] = attribute.getZ( i );\n\t\t\t\tif ( itemSize >= 4 ) array[ i + 3 ] = attribute.getW( i );\n\n\t\t\t}\n\n\t\t\treturn new THREE.BufferAttribute( array, itemSize, attribute.normalized );\n\n\t\t}\n\n\t\treturn attribute.clone();\n\n\t}\n\n\t/* GLTF PARSER */\n\n\tfunction GLTFParser( json, extensions, options ) {\n\n\t\tthis.json = json || {};\n\t\tthis.extensions = extensions || {};\n\t\tthis.options = options || {};\n\n\t\t// loader object cache\n\t\tthis.cache = new GLTFRegistry();\n\n\t\t// BufferGeometry caching\n\t\tthis.primitiveCache = [];\n\n\t\tthis.textureLoader = new THREE.TextureLoader( this.options.manager );\n\t\tthis.textureLoader.setCrossOrigin( this.options.crossOrigin );\n\n\t\tthis.fileLoader = new THREE.FileLoader( this.options.manager );\n\t\tthis.fileLoader.setResponseType( 'arraybuffer' );\n\n\t}\n\n\tGLTFParser.prototype.parse = function ( onLoad, onError ) {\n\n\t\tvar json = this.json;\n\n\t\t// Clear the loader cache\n\t\tthis.cache.removeAll();\n\n\t\t// Mark the special nodes/meshes in json for efficient parse\n\t\tthis.markDefs();\n\n\t\t// Fire the callback on complete\n\t\tthis.getMultiDependencies( [\n\n\t\t\t'scene',\n\t\t\t'animation',\n\t\t\t'camera'\n\n\t\t] ).then( function ( dependencies ) {\n\n\t\t\tvar scenes = dependencies.scenes || [];\n\t\t\tvar scene = scenes[ json.scene || 0 ];\n\t\t\tvar animations = dependencies.animations || [];\n\t\t\tvar asset = json.asset;\n\t\t\tvar cameras = dependencies.cameras || [];\n\n\t\t\tonLoad( scene, scenes, cameras, animations, asset );\n\n\t\t} ).catch( onError );\n\n\t};\n\n\t/**\n\t * Marks the special nodes/meshes in json for efficient parse.\n\t */\n\tGLTFParser.prototype.markDefs = function () {\n\n\t\tvar nodeDefs = this.json.nodes || [];\n\t\tvar skinDefs = this.json.skins || [];\n\t\tvar meshDefs = this.json.meshes || [];\n\n\t\tvar meshReferences = {};\n\t\tvar meshUses = {};\n\n\t\t// Nothing in the node definition indicates whether it is a Bone or an\n\t\t// Object3D. Use the skins' joint references to mark bones.\n\t\tfor ( var skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex ++ ) {\n\n\t\t\tvar joints = skinDefs[ skinIndex ].joints;\n\n\t\t\tfor ( var i = 0, il = joints.length; i < il; i ++ ) {\n\n\t\t\t\tnodeDefs[ joints[ i ] ].isBone = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Meshes can (and should) be reused by multiple nodes in a glTF asset. To\n\t\t// avoid having more than one THREE.Mesh with the same name, count\n\t\t// references and rename instances below.\n\t\t//\n\t\t// Example: CesiumMilkTruck sample model reuses \"Wheel\" meshes.\n\t\tfor ( var nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex ++ ) {\n\n\t\t\tvar nodeDef = nodeDefs[ nodeIndex ];\n\n\t\t\tif ( nodeDef.mesh !== undefined ) {\n\n\t\t\t\tif ( meshReferences[ nodeDef.mesh ] === undefined ) {\n\n\t\t\t\t\tmeshReferences[ nodeDef.mesh ] = meshUses[ nodeDef.mesh ] = 0;\n\n\t\t\t\t}\n\n\t\t\t\tmeshReferences[ nodeDef.mesh ] ++;\n\n\t\t\t\t// Nothing in the mesh definition indicates whether it is\n\t\t\t\t// a SkinnedMesh or Mesh. Use the node's mesh reference\n\t\t\t\t// to mark SkinnedMesh if node has skin.\n\t\t\t\tif ( nodeDef.skin !== undefined ) {\n\n\t\t\t\t\tmeshDefs[ nodeDef.mesh ].isSkinnedMesh = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.json.meshReferences = meshReferences;\n\t\tthis.json.meshUses = meshUses;\n\n\t};\n\n\t/**\n\t * Requests the specified dependency asynchronously, with caching.\n\t * @param {string} type\n\t * @param {number} index\n\t * @return {Promise<Object>}\n\t */\n\tGLTFParser.prototype.getDependency = function ( type, index ) {\n\n\t\tvar cacheKey = type + ':' + index;\n\t\tvar dependency = this.cache.get( cacheKey );\n\n\t\tif ( ! dependency ) {\n\n\t\t\tswitch ( type ) {\n\n\t\t\t\tcase 'scene':\n\t\t\t\t\tdependency = this.loadScene( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'node':\n\t\t\t\t\tdependency = this.loadNode( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'mesh':\n\t\t\t\t\tdependency = this.loadMesh( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'accessor':\n\t\t\t\t\tdependency = this.loadAccessor( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'bufferView':\n\t\t\t\t\tdependency = this.loadBufferView( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'buffer':\n\t\t\t\t\tdependency = this.loadBuffer( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'material':\n\t\t\t\t\tdependency = this.loadMaterial( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'texture':\n\t\t\t\t\tdependency = this.loadTexture( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'skin':\n\t\t\t\t\tdependency = this.loadSkin( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'animation':\n\t\t\t\t\tdependency = this.loadAnimation( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'camera':\n\t\t\t\t\tdependency = this.loadCamera( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error( 'Unknown type: ' + type );\n\n\t\t\t}\n\n\t\t\tthis.cache.add( cacheKey, dependency );\n\n\t\t}\n\n\t\treturn dependency;\n\n\t};\n\n\t/**\n\t * Requests all dependencies of the specified type asynchronously, with caching.\n\t * @param {string} type\n\t * @return {Promise<Array<Object>>}\n\t */\n\tGLTFParser.prototype.getDependencies = function ( type ) {\n\n\t\tvar dependencies = this.cache.get( type );\n\n\t\tif ( ! dependencies ) {\n\n\t\t\tvar parser = this;\n\t\t\tvar defs = this.json[ type + ( type === 'mesh' ? 'es' : 's' ) ] || [];\n\n\t\t\tdependencies = Promise.all( defs.map( function ( def, index ) {\n\n\t\t\t\treturn parser.getDependency( type, index );\n\n\t\t\t} ) );\n\n\t\t\tthis.cache.add( type, dependencies );\n\n\t\t}\n\n\t\treturn dependencies;\n\n\t};\n\n\t/**\n\t * Requests all multiple dependencies of the specified types asynchronously, with caching.\n\t * @param {Array<string>} types\n\t * @return {Promise<Object<Array<Object>>>}\n\t */\n\tGLTFParser.prototype.getMultiDependencies = function ( types ) {\n\n\t\tvar results = {};\n\t\tvar pendings = [];\n\n\t\tfor ( var i = 0, il = types.length; i < il; i ++ ) {\n\n\t\t\tvar type = types[ i ];\n\t\t\tvar value = this.getDependencies( type );\n\n\t\t\tvalue = value.then( function ( key, value ) {\n\n\t\t\t\tresults[ key ] = value;\n\n\t\t\t}.bind( this, type + ( type === 'mesh' ? 'es' : 's' ) ) );\n\n\t\t\tpendings.push( value );\n\n\t\t}\n\n\t\treturn Promise.all( pendings ).then( function () {\n\n\t\t\treturn results;\n\n\t\t} );\n\n\t};\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n\t * @param {number} bufferIndex\n\t * @return {Promise<ArrayBuffer>}\n\t */\n\tGLTFParser.prototype.loadBuffer = function ( bufferIndex ) {\n\n\t\tvar bufferDef = this.json.buffers[ bufferIndex ];\n\t\tvar loader = this.fileLoader;\n\n\t\tif ( bufferDef.type && bufferDef.type !== 'arraybuffer' ) {\n\n\t\t\tthrow new Error( 'THREE.GLTFLoader: ' + bufferDef.type + ' buffer type is not supported.' );\n\n\t\t}\n\n\t\t// If present, GLB container is required to be the first buffer.\n\t\tif ( bufferDef.uri === undefined && bufferIndex === 0 ) {\n\n\t\t\treturn Promise.resolve( this.extensions[ EXTENSIONS.KHR_BINARY_GLTF ].body );\n\n\t\t}\n\n\t\tvar options = this.options;\n\n\t\treturn new Promise( function ( resolve, reject ) {\n\n\t\t\tloader.load( resolveURL( bufferDef.uri, options.path ), resolve, undefined, function () {\n\n\t\t\t\treject( new Error( 'THREE.GLTFLoader: Failed to load buffer \"' + bufferDef.uri + '\".' ) );\n\n\t\t\t} );\n\n\t\t} );\n\n\t};\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n\t * @param {number} bufferViewIndex\n\t * @return {Promise<ArrayBuffer>}\n\t */\n\tGLTFParser.prototype.loadBufferView = function ( bufferViewIndex ) {\n\n\t\tvar bufferViewDef = this.json.bufferViews[ bufferViewIndex ];\n\n\t\treturn this.getDependency( 'buffer', bufferViewDef.buffer ).then( function ( buffer ) {\n\n\t\t\tvar byteLength = bufferViewDef.byteLength || 0;\n\t\t\tvar byteOffset = bufferViewDef.byteOffset || 0;\n\t\t\treturn buffer.slice( byteOffset, byteOffset + byteLength );\n\n\t\t} );\n\n\t};\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors\n\t * @param {number} accessorIndex\n\t * @return {Promise<THREE.BufferAttribute|THREE.InterleavedBufferAttribute>}\n\t */\n\tGLTFParser.prototype.loadAccessor = function ( accessorIndex ) {\n\n\t\tvar parser = this;\n\t\tvar json = this.json;\n\n\t\tvar accessorDef = this.json.accessors[ accessorIndex ];\n\n\t\tif ( accessorDef.bufferView === undefined && accessorDef.sparse === undefined ) {\n\n\t\t\t// Ignore empty accessors, which may be used to declare runtime\n\t\t\t// information about attributes coming from another source (e.g. Draco\n\t\t\t// compression extension).\n\t\t\treturn null;\n\n\t\t}\n\n\t\tvar pendingBufferViews = [];\n\n\t\tif ( accessorDef.bufferView !== undefined ) {\n\n\t\t\tpendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.bufferView ) );\n\n\t\t} else {\n\n\t\t\tpendingBufferViews.push( null );\n\n\t\t}\n\n\t\tif ( accessorDef.sparse !== undefined ) {\n\n\t\t\tpendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.sparse.indices.bufferView ) );\n\t\t\tpendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.sparse.values.bufferView ) );\n\n\t\t}\n\n\t\treturn Promise.all( pendingBufferViews ).then( function ( bufferViews ) {\n\n\t\t\tvar bufferView = bufferViews[ 0 ];\n\n\t\t\tvar itemSize = WEBGL_TYPE_SIZES[ accessorDef.type ];\n\t\t\tvar TypedArray = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ];\n\n\t\t\t// For VEC3: itemSize is 3, elementBytes is 4, itemBytes is 12.\n\t\t\tvar elementBytes = TypedArray.BYTES_PER_ELEMENT;\n\t\t\tvar itemBytes = elementBytes * itemSize;\n\t\t\tvar byteOffset = accessorDef.byteOffset || 0;\n\t\t\tvar byteStride = json.bufferViews[ accessorDef.bufferView ].byteStride;\n\t\t\tvar normalized = accessorDef.normalized === true;\n\t\t\tvar array, bufferAttribute;\n\n\t\t\t// The buffer is not interleaved if the stride is the item size in bytes.\n\t\t\tif ( byteStride && byteStride !== itemBytes ) {\n\n\t\t\t\tvar ibCacheKey = 'InterleavedBuffer:' + accessorDef.bufferView + ':' + accessorDef.componentType;\n\t\t\t\tvar ib = parser.cache.get( ibCacheKey );\n\n\t\t\t\tif ( ! ib ) {\n\n\t\t\t\t\t// Use the full buffer if it's interleaved.\n\t\t\t\t\tarray = new TypedArray( bufferView );\n\n\t\t\t\t\t// Integer parameters to IB/IBA are in array elements, not bytes.\n\t\t\t\t\tib = new THREE.InterleavedBuffer( array, byteStride / elementBytes );\n\n\t\t\t\t\tparser.cache.add( ibCacheKey, ib );\n\n\t\t\t\t}\n\n\t\t\t\tbufferAttribute = new THREE.InterleavedBufferAttribute( ib, itemSize, byteOffset / elementBytes, normalized );\n\n\t\t\t} else {\n\n\t\t\t\tif ( bufferView === null ) {\n\n\t\t\t\t\tarray = new TypedArray( accessorDef.count * itemSize );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tarray = new TypedArray( bufferView, byteOffset, accessorDef.count * itemSize );\n\n\t\t\t\t}\n\n\t\t\t\tbufferAttribute = new THREE.BufferAttribute( array, itemSize, normalized );\n\n\t\t\t}\n\n\t\t\t// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#sparse-accessors\n\t\t\tif ( accessorDef.sparse !== undefined ) {\n\n\t\t\t\tvar itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;\n\t\t\t\tvar TypedArrayIndices = WEBGL_COMPONENT_TYPES[ accessorDef.sparse.indices.componentType ];\n\n\t\t\t\tvar byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;\n\t\t\t\tvar byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;\n\n\t\t\t\tvar sparseIndices = new TypedArrayIndices( bufferViews[ 1 ], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices );\n\t\t\t\tvar sparseValues = new TypedArray( bufferViews[ 2 ], byteOffsetValues, accessorDef.sparse.count * itemSize );\n\n\t\t\t\tif ( bufferView !== null ) {\n\n\t\t\t\t\t// Avoid modifying the original ArrayBuffer, if the bufferView wasn't initialized with zeroes.\n\t\t\t\t\tbufferAttribute.setArray( bufferAttribute.array.slice() );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var i = 0, il = sparseIndices.length; i < il; i ++ ) {\n\n\t\t\t\t\tvar index = sparseIndices[ i ];\n\n\t\t\t\t\tbufferAttribute.setX( index, sparseValues[ i * itemSize ] );\n\t\t\t\t\tif ( itemSize >= 2 ) bufferAttribute.setY( index, sparseValues[ i * itemSize + 1 ] );\n\t\t\t\t\tif ( itemSize >= 3 ) bufferAttribute.setZ( index, sparseValues[ i * itemSize + 2 ] );\n\t\t\t\t\tif ( itemSize >= 4 ) bufferAttribute.setW( index, sparseValues[ i * itemSize + 3 ] );\n\t\t\t\t\tif ( itemSize >= 5 ) throw new Error( 'THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn bufferAttribute;\n\n\t\t} );\n\n\t};\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures\n\t * @param {number} textureIndex\n\t * @return {Promise<THREE.Texture>}\n\t */\n\tGLTFParser.prototype.loadTexture = function ( textureIndex ) {\n\n\t\tvar parser = this;\n\t\tvar json = this.json;\n\t\tvar options = this.options;\n\t\tvar textureLoader = this.textureLoader;\n\n\t\tvar URL = window.URL || window.webkitURL;\n\n\t\tvar textureDef = json.textures[ textureIndex ];\n\n\t\tvar textureExtensions = textureDef.extensions || {};\n\n\t\tvar source;\n\n\t\tif ( textureExtensions[ EXTENSIONS.MSFT_TEXTURE_DDS ] ) {\n\n\t\t\tsource = json.images[ textureExtensions[ EXTENSIONS.MSFT_TEXTURE_DDS ].source ];\n\n\t\t} else {\n\n\t\t\tsource = json.images[ textureDef.source ];\n\n\t\t}\n\n\t\tvar sourceURI = source.uri;\n\t\tvar isObjectURL = false;\n\n\t\tif ( source.bufferView !== undefined ) {\n\n\t\t\t// Load binary image data from bufferView, if provided.\n\n\t\t\tsourceURI = parser.getDependency( 'bufferView', source.bufferView ).then( function ( bufferView ) {\n\n\t\t\t\tisObjectURL = true;\n\t\t\t\tvar blob = new Blob( [ bufferView ], { type: source.mimeType } );\n\t\t\t\tsourceURI = URL.createObjectURL( blob );\n\t\t\t\treturn sourceURI;\n\n\t\t\t} );\n\n\t\t}\n\n\t\treturn Promise.resolve( sourceURI ).then( function ( sourceURI ) {\n\n\t\t\t// Load Texture resource.\n\n\t\t\tvar loader = THREE.Loader.Handlers.get( sourceURI );\n\n\t\t\tif ( ! loader ) {\n\n\t\t\t\tloader = textureExtensions[ EXTENSIONS.MSFT_TEXTURE_DDS ]\n\t\t\t\t\t? parser.extensions[ EXTENSIONS.MSFT_TEXTURE_DDS ].ddsLoader\n\t\t\t\t\t: textureLoader;\n\n\t\t\t}\n\n\t\t\treturn new Promise( function ( resolve, reject ) {\n\n\t\t\t\tloader.load( resolveURL( sourceURI, options.path ), resolve, undefined, reject );\n\n\t\t\t} );\n\n\t\t} ).then( function ( texture ) {\n\n\t\t\t// Clean up resources and configure Texture.\n\n\t\t\tif ( isObjectURL === true ) {\n\n\t\t\t\tURL.revokeObjectURL( sourceURI );\n\n\t\t\t}\n\n\t\t\ttexture.flipY = false;\n\n\t\t\tif ( textureDef.name !== undefined ) texture.name = textureDef.name;\n\n\t\t\t// .format of dds texture is set in DDSLoader\n\t\t\tif ( ! textureExtensions[ EXTENSIONS.MSFT_TEXTURE_DDS ] ) {\n\n\t\t\t\ttexture.format = textureDef.format !== undefined ? WEBGL_TEXTURE_FORMATS[ textureDef.format ] : THREE.RGBAFormat;\n\n\t\t\t}\n\n\t\t\tif ( textureDef.internalFormat !== undefined && texture.format !== WEBGL_TEXTURE_FORMATS[ textureDef.internalFormat ] ) {\n\n\t\t\t\tconsole.warn( 'THREE.GLTFLoader: Three.js does not support texture internalFormat which is different from texture format. ' +\n\t\t\t\t\t\t\t\t\t\t\t'internalFormat will be forced to be the same value as format.' );\n\n\t\t\t}\n\n\t\t\ttexture.type = textureDef.type !== undefined ? WEBGL_TEXTURE_DATATYPES[ textureDef.type ] : THREE.UnsignedByteType;\n\n\t\t\tvar samplers = json.samplers || {};\n\t\t\tvar sampler = samplers[ textureDef.sampler ] || {};\n\n\t\t\ttexture.magFilter = WEBGL_FILTERS[ sampler.magFilter ] || THREE.LinearFilter;\n\t\t\ttexture.minFilter = WEBGL_FILTERS[ sampler.minFilter ] || THREE.LinearMipMapLinearFilter;\n\t\t\ttexture.wrapS = WEBGL_WRAPPINGS[ sampler.wrapS ] || THREE.RepeatWrapping;\n\t\t\ttexture.wrapT = WEBGL_WRAPPINGS[ sampler.wrapT ] || THREE.RepeatWrapping;\n\n\t\t\treturn texture;\n\n\t\t} );\n\n\t};\n\n\t/**\n\t * Asynchronously assigns a texture to the given material parameters.\n\t * @param {Object} materialParams\n\t * @param {string} textureName\n\t * @param {number} textureIndex\n\t * @return {Promise}\n\t */\n\tGLTFParser.prototype.assignTexture = function ( materialParams, textureName, textureIndex ) {\n\n\t\treturn this.getDependency( 'texture', textureIndex ).then( function ( texture ) {\n\n\t\t\tmaterialParams[ textureName ] = texture;\n\n\t\t} );\n\n\t};\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials\n\t * @param {number} materialIndex\n\t * @return {Promise<THREE.Material>}\n\t */\n\tGLTFParser.prototype.loadMaterial = function ( materialIndex ) {\n\n\t\tvar parser = this;\n\t\tvar extensions = this.extensions;\n\t\tvar materialDef = this.json.materials[ materialIndex ];\n\n\t\tvar materialType;\n\t\tvar materialParams = {};\n\t\tvar materialExtensions = materialDef.extensions || {};\n\n\t\tvar pending = [];\n\n\t\tif ( materialExtensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ] ) {\n\n\t\t\tvar sgExtension = extensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ];\n\t\t\tmaterialType = sgExtension.getMaterialType( materialDef );\n\t\t\tpending.push( sgExtension.extendParams( materialParams, materialDef, parser ) );\n\n\t\t} else if ( materialExtensions[ EXTENSIONS.KHR_MATERIALS_UNLIT ] ) {\n\n\t\t\tvar kmuExtension = extensions[ EXTENSIONS.KHR_MATERIALS_UNLIT ];\n\t\t\tmaterialType = kmuExtension.getMaterialType( materialDef );\n\t\t\tpending.push( kmuExtension.extendParams( materialParams, materialDef, parser ) );\n\n\t\t} else {\n\n\t\t\t// Specification:\n\t\t\t// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#metallic-roughness-material\n\n\t\t\tmaterialType = THREE.MeshStandardMaterial;\n\n\t\t\tvar metallicRoughness = materialDef.pbrMetallicRoughness || {};\n\n\t\t\tmaterialParams.color = new THREE.Color( 1.0, 1.0, 1.0 );\n\t\t\tmaterialParams.opacity = 1.0;\n\n\t\t\tif ( Array.isArray( metallicRoughness.baseColorFactor ) ) {\n\n\t\t\t\tvar array = metallicRoughness.baseColorFactor;\n\n\t\t\t\tmaterialParams.color.fromArray( array );\n\t\t\t\tmaterialParams.opacity = array[ 3 ];\n\n\t\t\t}\n\n\t\t\tif ( metallicRoughness.baseColorTexture !== undefined ) {\n\n\t\t\t\tpending.push( parser.assignTexture( materialParams, 'map', metallicRoughness.baseColorTexture.index ) );\n\n\t\t\t}\n\n\t\t\tmaterialParams.metalness = metallicRoughness.metallicFactor !== undefined ? metallicRoughness.metallicFactor : 1.0;\n\t\t\tmaterialParams.roughness = metallicRoughness.roughnessFactor !== undefined ? metallicRoughness.roughnessFactor : 1.0;\n\n\t\t\tif ( metallicRoughness.metallicRoughnessTexture !== undefined ) {\n\n\t\t\t\tvar textureIndex = metallicRoughness.metallicRoughnessTexture.index;\n\t\t\t\tpending.push( parser.assignTexture( materialParams, 'metalnessMap', textureIndex ) );\n\t\t\t\tpending.push( parser.assignTexture( materialParams, 'roughnessMap', textureIndex ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( materialDef.doubleSided === true ) {\n\n\t\t\tmaterialParams.side = THREE.DoubleSide;\n\n\t\t}\n\n\t\tvar alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;\n\n\t\tif ( alphaMode === ALPHA_MODES.BLEND ) {\n\n\t\t\tmaterialParams.transparent = true;\n\n\t\t} else {\n\n\t\t\tmaterialParams.transparent = false;\n\n\t\t\tif ( alphaMode === ALPHA_MODES.MASK ) {\n\n\t\t\t\tmaterialParams.alphaTest = materialDef.alphaCutoff !== undefined ? materialDef.alphaCutoff : 0.5;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( materialDef.normalTexture !== undefined && materialType !== THREE.MeshBasicMaterial) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'normalMap', materialDef.normalTexture.index ) );\n\n\t\t\tmaterialParams.normalScale = new THREE.Vector2( 1, 1 );\n\n\t\t\tif ( materialDef.normalTexture.scale !== undefined ) {\n\n\t\t\t\tmaterialParams.normalScale.set( materialDef.normalTexture.scale, materialDef.normalTexture.scale );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( materialDef.occlusionTexture !== undefined && materialType !== THREE.MeshBasicMaterial) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'aoMap', materialDef.occlusionTexture.index ) );\n\n\t\t\tif ( materialDef.occlusionTexture.strength !== undefined ) {\n\n\t\t\t\tmaterialParams.aoMapIntensity = materialDef.occlusionTexture.strength;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( materialDef.emissiveFactor !== undefined && materialType !== THREE.MeshBasicMaterial) {\n\n\t\t\tmaterialParams.emissive = new THREE.Color().fromArray( materialDef.emissiveFactor );\n\n\t\t}\n\n\t\tif ( materialDef.emissiveTexture !== undefined && materialType !== THREE.MeshBasicMaterial) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'emissiveMap', materialDef.emissiveTexture.index ) );\n\n\t\t}\n\n\t\treturn Promise.all( pending ).then( function () {\n\n\t\t\tvar material;\n\n\t\t\tif ( materialType === THREE.ShaderMaterial ) {\n\n\t\t\t\tmaterial = extensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ].createMaterial( materialParams );\n\n\t\t\t} else {\n\n\t\t\t\tmaterial = new materialType( materialParams );\n\n\t\t\t}\n\n\t\t\tif ( materialDef.name !== undefined ) material.name = materialDef.name;\n\n\t\t\t// Normal map textures use OpenGL conventions:\n\t\t\t// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#materialnormaltexture\n\t\t\tif ( material.normalScale ) {\n\n\t\t\t\tmaterial.normalScale.y = - material.normalScale.y;\n\n\t\t\t}\n\n\t\t\t// emissiveTexture and baseColorTexture use sRGB encoding.\n\t\t\tif ( material.map ) material.map.encoding = THREE.sRGBEncoding;\n\t\t\tif ( material.emissiveMap ) material.emissiveMap.encoding = THREE.sRGBEncoding;\n\n\t\t\tif ( materialDef.extras ) material.userData = materialDef.extras;\n\n\t\t\treturn material;\n\n\t\t} );\n\n\t};\n\n\t/**\n\t * @param  {THREE.BufferGeometry} geometry\n\t * @param  {GLTF.Primitive} primitiveDef\n\t * @param  {Array<THREE.BufferAttribute>} accessors\n\t */\n\tfunction addPrimitiveAttributes ( geometry, primitiveDef, accessors ) {\n\n\t\tvar attributes = primitiveDef.attributes;\n\n\t\tfor ( var gltfAttributeName in attributes ) {\n\n\t\t\tvar threeAttributeName = ATTRIBUTES[ gltfAttributeName ];\n\t\t\tvar bufferAttribute = accessors[ attributes[ gltfAttributeName ] ];\n\n\t\t\t// Skip attributes already provided by e.g. Draco extension.\n\t\t\tif ( !threeAttributeName ) continue;\n\t\t\tif ( threeAttributeName in geometry.attributes ) continue;\n\n\t\t\tgeometry.addAttribute( threeAttributeName, bufferAttribute );\n\n\t\t}\n\n\t\tif ( primitiveDef.indices !== undefined && !geometry.index ) {\n\n\t\t\tgeometry.setIndex( accessors[ primitiveDef.indices ] );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry\n\t * @param {Array<Object>} primitives\n\t * @return {Promise<Array<THREE.BufferGeometry>>}\n\t */\n\tGLTFParser.prototype.loadGeometries = function ( primitives ) {\n\n\t\tvar parser = this;\n\t\tvar extensions = this.extensions;\n\t\tvar cache = this.primitiveCache;\n\n\n\n\t\treturn this.getDependencies( 'accessor' ).then( function ( accessors ) {\n\n\t\t\tfunction addPrimitives (geometry) {\n\t\t\t\taddPrimitiveAttributes( geometry, primitive, accessors );\n\t\t\t\treturn geometry;\n\t\t\t};\n\n\t\t\tvar pending = [];\n\t\t\tvar geometryPromise = null;\n\n\t\t\tfor ( var i = 0, il = primitives.length; i < il; i ++ ) {\n\n\t\t\t\tvar primitive = primitives[ i ];\n\n\t\t\t\t// See if we've already created this geometry\n\t\t\t\tvar cached = getCachedGeometry( cache, primitive );\n\n\t\t\t\tif ( cached ) {\n\n\t\t\t\t\t// Use the cached geometry if it exists\n\t\t\t\t\tpending.push( cached );\n\n\t\t\t\t} else if ( primitive.extensions && primitive.extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ] ) {\n\n\t\t\t\t\t// Use DRACO geometry if available\n\t\t\t\t\tgeometryPromise = extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ]\n\t\t\t\t\t\t.decodePrimitive( primitive, parser )\n\t\t\t\t\t\t.then(addPrimitives);\n\n\t\t\t\t\tcache.push( { primitive: primitive, promise: geometryPromise } );\n\n\t\t\t\t\tpending.push( geometryPromise );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// Otherwise create a new geometry\n\t\t\t\t\tvar geometry = new THREE.BufferGeometry();\n\n\t\t\t\t\taddPrimitiveAttributes( geometry, primitive, accessors );\n\n\t\t\t\t\tgeometryPromise = Promise.resolve( geometry );\n\n\t\t\t\t\t// Cache this geometry\n\t\t\t\t\tcache.push( {\n\n\t\t\t\t\t\tprimitive: primitive,\n\t\t\t\t\t\tpromise: geometryPromise\n\n\t\t\t\t\t} );\n\n\t\t\t\t\tpending.push( geometryPromise );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn Promise.all( pending );\n\n\t\t} );\n\n\t};\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes\n\t * @param {number} meshIndex\n\t * @return {Promise<THREE.Group|THREE.Mesh|THREE.SkinnedMesh>}\n\t */\n\tGLTFParser.prototype.loadMesh = function ( meshIndex ) {\n\n\t\tvar scope = this;\n\t\tvar extensions = this.extensions;\n\n\t\tvar meshDef = this.json.meshes[ meshIndex ];\n\n\t\treturn this.getMultiDependencies( [\n\n\t\t\t'accessor',\n\t\t\t'material'\n\n\t\t] ).then( function ( dependencies ) {\n\n\t\t\tvar group = new THREE.Group();\n\n\t\t\tvar primitives = meshDef.primitives;\n\n\t\t\treturn scope.loadGeometries( primitives ).then( function ( geometries ) {\n\n\t\t\t\tfor ( var i = 0, il = primitives.length; i < il; i ++ ) {\n\n\t\t\t\t\tvar primitive = primitives[ i ];\n\t\t\t\t\tvar geometry = geometries[ i ];\n\n\t\t\t\t\tvar material = primitive.material === undefined\n\t\t\t\t\t\t? createDefaultMaterial()\n\t\t\t\t\t\t: dependencies.materials[ primitive.material ];\n\n\t\t\t\t\tif ( material.aoMap\n\t\t\t\t\t\t\t&& geometry.attributes.uv2 === undefined\n\t\t\t\t\t\t\t&& geometry.attributes.uv !== undefined ) {\n\n\t\t\t\t\t\tconsole.log( 'THREE.GLTFLoader: Duplicating UVs to support aoMap.' );\n\t\t\t\t\t\tgeometry.addAttribute( 'uv2', new THREE.BufferAttribute( geometry.attributes.uv.array, 2 ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// If the material will be modified later on, clone it now.\n\t\t\t\t\tvar useVertexColors = geometry.attributes.color !== undefined;\n\t\t\t\t\tvar useFlatShading = geometry.attributes.normal === undefined;\n\t\t\t\t\tvar useSkinning = meshDef.isSkinnedMesh === true;\n\t\t\t\t\tvar useMorphTargets = primitive.targets !== undefined;\n\n\t\t\t\t\tif ( useVertexColors || useFlatShading || useSkinning || useMorphTargets ) {\n\n\t\t\t\t\t\tif ( material.isGLTFSpecularGlossinessMaterial ) {\n\n\t\t\t\t\t\t\tvar specGlossExtension = extensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ];\n\t\t\t\t\t\t\tmaterial = specGlossExtension.cloneMaterial( material );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tmaterial = material.clone();\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( useVertexColors ) {\n\n\t\t\t\t\t\tmaterial.vertexColors = THREE.VertexColors;\n\t\t\t\t\t\tmaterial.needsUpdate = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( useFlatShading ) {\n\n\t\t\t\t\t\tmaterial.flatShading = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar mesh;\n\t\t\t\t\tvar cacheKey;\n\n\t\t\t\t\tif ( primitive.mode === WEBGL_CONSTANTS.TRIANGLES ||\n\t\t\t\t\t\tprimitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ||\n\t\t\t\t\t\tprimitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN ||\n\t\t\t\t\t\tprimitive.mode === undefined ) {\n\n\t\t\t\t\t\tif ( useSkinning ) {\n\n\t\t\t\t\t\t\tmesh = new THREE.SkinnedMesh( geometry, material );\n\t\t\t\t\t\t\tmaterial.skinning = true;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tmesh = new THREE.Mesh( geometry, material );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ) {\n\n\t\t\t\t\t\t\tmesh.drawMode = THREE.TriangleStripDrawMode;\n\n\t\t\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN ) {\n\n\t\t\t\t\t\t\tmesh.drawMode = THREE.TriangleFanDrawMode;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.LINES ||\n\t\t\t\t\t\tprimitive.mode === WEBGL_CONSTANTS.LINE_STRIP ||\n\t\t\t\t\t\tprimitive.mode === WEBGL_CONSTANTS.LINE_LOOP ) {\n\n\t\t\t\t\t\tcacheKey = 'LineBasicMaterial:' + material.uuid;\n\n\t\t\t\t\t\tvar lineMaterial = scope.cache.get( cacheKey );\n\n\t\t\t\t\t\tif ( ! lineMaterial ) {\n\n\t\t\t\t\t\t\tlineMaterial = new THREE.LineBasicMaterial();\n\t\t\t\t\t\t\tTHREE.Material.prototype.copy.call( lineMaterial, material );\n\t\t\t\t\t\t\tlineMaterial.color.copy( material.color );\n\t\t\t\t\t\t\tlineMaterial.lights = false;  // LineBasicMaterial doesn't support lights yet\n\n\t\t\t\t\t\t\tscope.cache.add( cacheKey, lineMaterial );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tmaterial = lineMaterial;\n\n\t\t\t\t\t\tif ( primitive.mode === WEBGL_CONSTANTS.LINES ) {\n\n\t\t\t\t\t\t\tmesh = new THREE.LineSegments( geometry, material );\n\n\t\t\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.LINE_STRIP ) {\n\n\t\t\t\t\t\t\tmesh = new THREE.Line( geometry, material );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tmesh = new THREE.LineLoop( geometry, material );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.POINTS ) {\n\n\t\t\t\t\t\tcacheKey = 'PointsMaterial:' + material.uuid;\n\n\t\t\t\t\t\tvar pointsMaterial = scope.cache.get( cacheKey );\n\n\t\t\t\t\t\tif ( ! pointsMaterial ) {\n\n\t\t\t\t\t\t\tpointsMaterial = new THREE.PointsMaterial();\n\t\t\t\t\t\t\tTHREE.Material.prototype.copy.call( pointsMaterial, material );\n\t\t\t\t\t\t\tpointsMaterial.color.copy( material.color );\n\t\t\t\t\t\t\tpointsMaterial.map = material.map;\n\t\t\t\t\t\t\tpointsMaterial.lights = false;  // PointsMaterial doesn't support lights yet\n\n\t\t\t\t\t\t\tscope.cache.add( cacheKey, pointsMaterial );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tmaterial = pointsMaterial;\n\n\t\t\t\t\t\tmesh = new THREE.Points( geometry, material );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthrow new Error( 'THREE.GLTFLoader: Primitive mode unsupported: ' + primitive.mode );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tmesh.name = meshDef.name || ( 'mesh_' + meshIndex );\n\n\t\t\t\t\tif ( useMorphTargets ) {\n\n\t\t\t\t\t\taddMorphTargets( mesh, meshDef, primitive, dependencies.accessors );\n\n\t\t\t\t\t\tmaterial.morphTargets = true;\n\n\t\t\t\t\t\tif ( mesh.geometry.morphAttributes.normal !== undefined ) material.morphNormals = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( meshDef.extras !== undefined ) mesh.userData = meshDef.extras;\n\t\t\t\t\tif ( primitive.extras !== undefined ) mesh.geometry.userData = primitive.extras;\n\n\t\t\t\t\t// for Specular-Glossiness.\n\t\t\t\t\tif ( material.isGLTFSpecularGlossinessMaterial === true ) {\n\n\t\t\t\t\t\tmesh.onBeforeRender = extensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ].refreshUniforms;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( primitives.length > 1 ) {\n\n\t\t\t\t\t\tmesh.name += '_' + i;\n\n\t\t\t\t\t\tgroup.add( mesh );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\treturn mesh;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn group;\n\n\t\t\t} );\n\n\t\t} );\n\n\t};\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras\n\t * @param {number} cameraIndex\n\t * @return {Promise<THREE.Camera>}\n\t */\n\tGLTFParser.prototype.loadCamera = function ( cameraIndex ) {\n\n\t\tvar camera;\n\t\tvar cameraDef = this.json.cameras[ cameraIndex ];\n\t\tvar params = cameraDef[ cameraDef.type ];\n\n\t\tif ( ! params ) {\n\n\t\t\tconsole.warn( 'THREE.GLTFLoader: Missing camera parameters.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( cameraDef.type === 'perspective' ) {\n\n\t\t\tcamera = new THREE.PerspectiveCamera( THREE.Math.radToDeg( params.yfov ), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6 );\n\n\t\t} else if ( cameraDef.type === 'orthographic' ) {\n\n\t\t\tcamera = new THREE.OrthographicCamera( params.xmag / - 2, params.xmag / 2, params.ymag / 2, params.ymag / - 2, params.znear, params.zfar );\n\n\t\t}\n\n\t\tif ( cameraDef.name !== undefined ) camera.name = cameraDef.name;\n\t\tif ( cameraDef.extras ) camera.userData = cameraDef.extras;\n\n\t\treturn Promise.resolve( camera );\n\n\t};\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins\n\t * @param {number} skinIndex\n\t * @return {Promise<Object>}\n\t */\n\tGLTFParser.prototype.loadSkin = function ( skinIndex ) {\n\n\t\tvar skinDef = this.json.skins[ skinIndex ];\n\n\t\tvar skinEntry = { joints: skinDef.joints };\n\n\t\tif ( skinDef.inverseBindMatrices === undefined ) {\n\n\t\t\treturn Promise.resolve( skinEntry );\n\n\t\t}\n\n\t\treturn this.getDependency( 'accessor', skinDef.inverseBindMatrices ).then( function ( accessor ) {\n\n\t\t\tskinEntry.inverseBindMatrices = accessor;\n\n\t\t\treturn skinEntry;\n\n\t\t} );\n\n\t};\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations\n\t * @param {number} animationIndex\n\t * @return {Promise<THREE.AnimationClip>}\n\t */\n\tGLTFParser.prototype.loadAnimation = function ( animationIndex ) {\n\n\t\tvar animationDef = this.json.animations[ animationIndex ];\n\n\t\treturn this.getMultiDependencies( [\n\n\t\t\t'accessor',\n\t\t\t'node'\n\n\t\t] ).then( function ( dependencies ) {\n\n\t\t\tvar tracks = [];\n\n\t\t\tfunction pushToTargetNames ( object ) {\n\t\t\t\tif ( object.isMesh === true && object.material.morphTargets === true ) {\n\n\t\t\t\t\ttargetNames.push( object.name ? object.name : object.uuid );\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor ( var i = 0, il = animationDef.channels.length; i < il; i ++ ) {\n\n\t\t\t\tvar channel = animationDef.channels[ i ];\n\t\t\t\tvar sampler = animationDef.samplers[ channel.sampler ];\n\t\t\t\tvar name;\n\n\t\t\t\tif ( sampler ) {\n\n\t\t\t\t\tvar target = channel.target;\n\t\t\t\t\tname = target.node !== undefined ? target.node : target.id; // NOTE: target.id is deprecated.\n\t\t\t\t\tvar input = animationDef.parameters !== undefined ? animationDef.parameters[ sampler.input ] : sampler.input;\n\t\t\t\t\tvar output = animationDef.parameters !== undefined ? animationDef.parameters[ sampler.output ] : sampler.output;\n\n\t\t\t\t\tvar inputAccessor = dependencies.accessors[ input ];\n\t\t\t\t\tvar outputAccessor = dependencies.accessors[ output ];\n\n\t\t\t\t\tvar node = dependencies.nodes[ name ];\n\n\t\t\t\t\tif ( node ) {\n\n\t\t\t\t\t\tnode.updateMatrix();\n\t\t\t\t\t\tnode.matrixAutoUpdate = true;\n\n\t\t\t\t\t\tvar TypedKeyframeTrack;\n\n\t\t\t\t\t\tswitch ( PATH_PROPERTIES[ target.path ] ) {\n\n\t\t\t\t\t\t\tcase PATH_PROPERTIES.weights:\n\n\t\t\t\t\t\t\t\tTypedKeyframeTrack = THREE.NumberKeyframeTrack;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase PATH_PROPERTIES.rotation:\n\n\t\t\t\t\t\t\t\tTypedKeyframeTrack = THREE.QuaternionKeyframeTrack;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase PATH_PROPERTIES.position:\n\t\t\t\t\t\t\tcase PATH_PROPERTIES.scale:\n\t\t\t\t\t\t\tdefault:\n\n\t\t\t\t\t\t\t\tTypedKeyframeTrack = THREE.VectorKeyframeTrack;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar targetName = node.name ? node.name : node.uuid;\n\n\t\t\t\t\t\tvar interpolation = sampler.interpolation !== undefined ? INTERPOLATION[ sampler.interpolation ] : THREE.InterpolateLinear;\n\n\t\t\t\t\t\tvar targetNames = [];\n\n\t\t\t\t\t\tif ( PATH_PROPERTIES[ target.path ] === PATH_PROPERTIES.weights ) {\n\n\t\t\t\t\t\t\t// node should be THREE.Group here but\n\t\t\t\t\t\t\t// PATH_PROPERTIES.weights(morphTargetInfluences) should be\n\t\t\t\t\t\t\t// the property of a mesh object under node.\n\t\t\t\t\t\t\t// So finding targets here.\n\n\t\t\t\t\t\t\tnode.traverse( pushToTargetNames );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\ttargetNames.push( targetName );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// KeyframeTrack.optimize() will modify given 'times' and 'values'\n\t\t\t\t\t\t// buffers before creating a truncated copy to keep. Because buffers may\n\t\t\t\t\t\t// be reused by other tracks, make copies here.\n\t\t\t\t\t\tfor ( var j = 0, jl = targetNames.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\tvar track = new TypedKeyframeTrack(\n\t\t\t\t\t\t\t\ttargetNames[ j ] + '.' + PATH_PROPERTIES[ target.path ],\n\t\t\t\t\t\t\t\tTHREE.AnimationUtils.arraySlice( inputAccessor.array, 0 ),\n\t\t\t\t\t\t\t\tTHREE.AnimationUtils.arraySlice( outputAccessor.array, 0 ),\n\t\t\t\t\t\t\t\tinterpolation\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t// Here is the trick to enable custom interpolation.\n\t\t\t\t\t\t\t// Overrides .createInterpolant in a factory method which creates custom interpolation.\n\t\t\t\t\t\t\tif ( sampler.interpolation === 'CUBICSPLINE' ) {\n\n\t\t\t\t\t\t\t\ttrack.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline( result ) {\n\n\t\t\t\t\t\t\t\t\t// A CUBICSPLINE keyframe in glTF has three output values for each input value,\n\t\t\t\t\t\t\t\t\t// representing inTangent, splineVertex, and outTangent. As a result, track.getValueSize()\n\t\t\t\t\t\t\t\t\t// must be divided by three to get the interpolant's sampleSize argument.\n\n\t\t\t\t\t\t\t\t\treturn new GLTFCubicSplineInterpolant( this.times, this.values, this.getValueSize() / 3, result );\n\n\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\t// Workaround, provide an alternate way to know if the interpolant type is cubis spline to track.\n\t\t\t\t\t\t\t\t// track.getInterpolation() doesn't return valid value for custom interpolant.\n\t\t\t\t\t\t\t\ttrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\ttracks.push( track );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tname = animationDef.name !== undefined ? animationDef.name : 'animation_' + animationIndex;\n\n\t\t\treturn new THREE.AnimationClip( name, undefined, tracks );\n\n\t\t} );\n\n\t};\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy\n\t * @param {number} nodeIndex\n\t * @return {Promise<THREE.Object3D>}\n\t */\n\tGLTFParser.prototype.loadNode = function ( nodeIndex ) {\n\n\t\tvar extensions = this.extensions;\n\n\t\tvar meshReferences = this.json.meshReferences;\n\t\tvar meshUses = this.json.meshUses;\n\n\t\tvar nodeDef = this.json.nodes[ nodeIndex ];\n\n\t\treturn this.getMultiDependencies( [\n\n\t\t\t'mesh',\n\t\t\t'skin',\n\t\t\t'camera',\n\t\t\t'light'\n\n\t\t] ).then( function ( dependencies ) {\n\n\t\t\tvar node;\n\n\t\t\tif ( nodeDef.isBone === true ) {\n\n\t\t\t\tnode = new THREE.Bone();\n\n\t\t\t} else if ( nodeDef.mesh !== undefined ) {\n\n\t\t\t\tvar mesh = dependencies.meshes[ nodeDef.mesh ];\n\n\t\t\t\tnode = mesh.clone();\n\n\t\t\t\t// for Specular-Glossiness\n\t\t\t\tif ( mesh.isGroup === true ) {\n\n\t\t\t\t\tfor ( var i = 0, il = mesh.children.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tvar child = mesh.children[ i ];\n\n\t\t\t\t\t\tif ( child.material && child.material.isGLTFSpecularGlossinessMaterial === true ) {\n\n\t\t\t\t\t\t\tnode.children[ i ].onBeforeRender = child.onBeforeRender;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( mesh.material && mesh.material.isGLTFSpecularGlossinessMaterial === true ) {\n\n\t\t\t\t\t\tnode.onBeforeRender = mesh.onBeforeRender;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( meshReferences[ nodeDef.mesh ] > 1 ) {\n\n\t\t\t\t\tnode.name += '_instance_' + meshUses[ nodeDef.mesh ] ++;\n\n\t\t\t\t}\n\n\t\t\t} else if ( nodeDef.camera !== undefined ) {\n\n\t\t\t\tnode = dependencies.cameras[ nodeDef.camera ];\n\n\t\t\t} else if ( nodeDef.extensions\n\t\t\t\t\t && nodeDef.extensions[ EXTENSIONS.KHR_LIGHTS ]\n\t\t\t\t\t && nodeDef.extensions[ EXTENSIONS.KHR_LIGHTS ].light !== undefined ) {\n\n\t\t\t\tvar lights = extensions[ EXTENSIONS.KHR_LIGHTS ].lights;\n\t\t\t\tnode = lights[ nodeDef.extensions[ EXTENSIONS.KHR_LIGHTS ].light ];\n\n\t\t\t} else {\n\n\t\t\t\tnode = new THREE.Object3D();\n\n\t\t\t}\n\n\t\t\tif ( nodeDef.name !== undefined ) {\n\n\t\t\t\tnode.name = THREE.PropertyBinding.sanitizeNodeName( nodeDef.name );\n\n\t\t\t}\n\n\t\t\tif ( nodeDef.extras ) node.userData = nodeDef.extras;\n\n\t\t\tif ( nodeDef.matrix !== undefined ) {\n\n\t\t\t\tvar matrix = new THREE.Matrix4();\n\t\t\t\tmatrix.fromArray( nodeDef.matrix );\n\t\t\t\tnode.applyMatrix( matrix );\n\n\t\t\t} else {\n\n\t\t\t\tif ( nodeDef.translation !== undefined ) {\n\n\t\t\t\t\tnode.position.fromArray( nodeDef.translation );\n\n\t\t\t\t}\n\n\t\t\t\tif ( nodeDef.rotation !== undefined ) {\n\n\t\t\t\t\tnode.quaternion.fromArray( nodeDef.rotation );\n\n\t\t\t\t}\n\n\t\t\t\tif ( nodeDef.scale !== undefined ) {\n\n\t\t\t\t\tnode.scale.fromArray( nodeDef.scale );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn node;\n\n\t\t} );\n\n\t};\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes\n\t * @param {number} sceneIndex\n\t * @return {Promise<THREE.Scene>}\n\t */\n\tGLTFParser.prototype.loadScene = function () {\n\n\t\t// scene node hierachy builder\n\n\t\tfunction buildNodeHierachy( nodeId, parentObject, json, allNodes, skins ) {\n\n\t\t\tvar node = allNodes[ nodeId ];\n\t\t\tvar nodeDef = json.nodes[ nodeId ];\n\n\t\t\t// build skeleton here as well\n\n\t\t\tif ( nodeDef.skin !== undefined ) {\n\n\t\t\t\tvar meshes = node.isGroup === true ? node.children : [ node ];\n\n\t\t\t\tfor ( var i = 0, il = meshes.length; i < il; i ++ ) {\n\n\t\t\t\t\tvar mesh = meshes[ i ];\n\t\t\t\t\tvar skinEntry = skins[ nodeDef.skin ];\n\n\t\t\t\t\tvar bones = [];\n\t\t\t\t\tvar boneInverses = [];\n\n\t\t\t\t\tfor ( var j = 0, jl = skinEntry.joints.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\tvar jointId = skinEntry.joints[ j ];\n\t\t\t\t\t\tvar jointNode = allNodes[ jointId ];\n\n\t\t\t\t\t\tif ( jointNode ) {\n\n\t\t\t\t\t\t\tbones.push( jointNode );\n\n\t\t\t\t\t\t\tvar mat = new THREE.Matrix4();\n\n\t\t\t\t\t\t\tif ( skinEntry.inverseBindMatrices !== undefined ) {\n\n\t\t\t\t\t\t\t\tmat.fromArray( skinEntry.inverseBindMatrices.array, j * 16 );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tboneInverses.push( mat );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tconsole.warn( 'THREE.GLTFLoader: Joint \"%s\" could not be found.', jointId );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tmesh.bind( new THREE.Skeleton( bones, boneInverses ), mesh.matrixWorld );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// build node hierachy\n\n\t\t\tparentObject.add( node );\n\n\t\t\tif ( nodeDef.children ) {\n\n\t\t\t\tvar children = nodeDef.children;\n\n\t\t\t\tfor ( let i = 0, il = children.length; i < il; i ++ ) {\n\n\t\t\t\t\tvar child = children[ i ];\n\t\t\t\t\tbuildNodeHierachy( child, node, json, allNodes, skins );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn function loadScene( sceneIndex ) {\n\n\t\t\tvar json = this.json;\n\t\t\tvar extensions = this.extensions;\n\t\t\tvar sceneDef = this.json.scenes[ sceneIndex ];\n\n\t\t\treturn this.getMultiDependencies( [\n\n\t\t\t\t'node',\n\t\t\t\t'skin'\n\n\t\t\t] ).then( function ( dependencies ) {\n\n\t\t\t\tvar scene = new THREE.Scene();\n\t\t\t\tif ( sceneDef.name !== undefined ) scene.name = sceneDef.name;\n\n\t\t\t\tif ( sceneDef.extras ) scene.userData = sceneDef.extras;\n\n\t\t\t\tvar nodeIds = sceneDef.nodes || [];\n\n\t\t\t\tfor ( var i = 0, il = nodeIds.length; i < il; i ++ ) {\n\n\t\t\t\t\tbuildNodeHierachy( nodeIds[ i ], scene, json, dependencies.nodes, dependencies.skins );\n\n\t\t\t\t}\n\n\t\t\t\t// Ambient lighting, if present, is always attached to the scene root.\n\t\t\t\tif ( sceneDef.extensions\n\t\t\t\t\t\t && sceneDef.extensions[ EXTENSIONS.KHR_LIGHTS ]\n\t\t\t\t\t\t && sceneDef.extensions[ EXTENSIONS.KHR_LIGHTS ].light !== undefined ) {\n\n\t\t\t\t\tvar lights = extensions[ EXTENSIONS.KHR_LIGHTS ].lights;\n\t\t\t\t\tscene.add( lights[ sceneDef.extensions[ EXTENSIONS.KHR_LIGHTS ].light ] );\n\n\t\t\t\t}\n\n\t\t\t\treturn scene;\n\n\t\t\t} );\n\n\t\t};\n\n\t}();\n\n\treturn GLTFLoader;\n\n} )();\n\nexport default GLTFLoader;"]},"metadata":{},"sourceType":"module"}